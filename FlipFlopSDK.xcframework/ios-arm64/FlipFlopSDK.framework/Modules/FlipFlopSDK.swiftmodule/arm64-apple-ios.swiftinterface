// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.4 (swiftlang-1205.0.26.9 clang-1205.0.19.55)
// swift-module-flags: -target arm64-apple-ios11.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name FlipFlopSDK
import AVFoundation
import AVKit
import AWSLogs
import AWSS3
import AudioToolbox
import CommonCrypto
import CoreAudio
import CoreFoundation
import CoreImage
import CoreMedia
import CoreVideo
import Dispatch
import Foundation
import GLKit
import ImageIO
import MetalKit
import Network
import SocketRocket
import Swift
import SystemConfiguration
import UIKit
import VideoToolbox
import WebRTC
import zlib
public let kASUndefined: FlipFlopSDK.ASUndefined
public typealias ASObject = [Swift.String : Any?]
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class ASUndefined : ObjectiveC.NSObject {
  @objc override final public var description: Swift.String {
    @objc get
  }
  @objc deinit
}
public struct ASTypedObject {
  public typealias TypedObjectDecoder = (Swift.String, FlipFlopSDK.ASObject) throws -> Any
  public static func register(typeNamed name: Swift.String, decoder: @escaping FlipFlopSDK.ASTypedObject.TypedObjectDecoder)
  public static func register<T>(type: T.Type, named name: Swift.String) where T : Swift.Decodable
  public static func unregister(typeNamed name: Swift.String)
}
public struct ASArray {
  public var length: Swift.Int {
    get
  }
  public init(count: Swift.Int)
  public init(data: [Any?])
}
extension ASArray : Swift.ExpressibleByArrayLiteral {
  public init(arrayLiteral elements: Any?...)
  public subscript(i: Any) -> Any? {
    get
    set
  }
  public typealias ArrayLiteralElement = Any?
}
extension ASArray : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension ASArray : Swift.Equatable {
  public static func == (lhs: FlipFlopSDK.ASArray, rhs: FlipFlopSDK.ASArray) -> Swift.Bool
}
@objc final public class ASXMLDocument : ObjectiveC.NSObject {
  @objc override final public var description: Swift.String {
    @objc get
  }
  public init(data: Swift.String)
  @objc override dynamic public init()
  @objc deinit
}
@objc final public class ASXML : ObjectiveC.NSObject {
  @objc override final public var description: Swift.String {
    @objc get
  }
  public init(data: Swift.String)
  @objc override dynamic public init()
  @objc deinit
}
public struct Semaphore {
  public init(poolSize: Swift.Int = 0)
  @discardableResult
  public func wait(_ timeout: Dispatch.DispatchTime = .distantFuture) -> Dispatch.DispatchTimeoutResult
  @discardableResult
  public func `continue`() -> Swift.Int
}
public enum CloseCode : Swift.UInt16 {
  case normal
  case goingAway
  case protocolError
  case protocolUnhandledType
  case noStatusReceived
  case encoding
  case policyViolated
  case messageTooBig
  public init?(rawValue: Swift.UInt16)
  public typealias RawValue = Swift.UInt16
  public var rawValue: Swift.UInt16 {
    get
  }
}
public enum FrameOpCode : Swift.UInt8 {
  case continueFrame
  case textFrame
  case binaryFrame
  case connectionClose
  case ping
  case pong
  case unknown
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public struct Frame {
}
public enum FrameEvent {
  case frame(FlipFlopSDK.Frame)
  case error(Swift.Error)
}
public protocol FramerEventClient : AnyObject {
  func frameProcessed(event: FlipFlopSDK.FrameEvent)
}
public protocol Framer {
  func add(data: Foundation.Data)
  func register(delegate: FlipFlopSDK.FramerEventClient)
  func createWriteFrame(opcode: FlipFlopSDK.FrameOpCode, payload: Foundation.Data, isCompressed: Swift.Bool) -> Foundation.Data
  func updateCompression(supports: Swift.Bool)
  func supportsCompression() -> Swift.Bool
}
public class WSFramer : FlipFlopSDK.Framer {
  public var compressionEnabled: Swift.Bool
  public init(isServer: Swift.Bool = false)
  public func updateCompression(supports: Swift.Bool)
  public func supportsCompression() -> Swift.Bool
  public func add(data: Foundation.Data)
  public func register(delegate: FlipFlopSDK.FramerEventClient)
  public func createWriteFrame(opcode: FlipFlopSDK.FrameOpCode, payload: Foundation.Data, isCompressed: Swift.Bool) -> Foundation.Data
  @objc deinit
}
public protocol MyWSArrayType {
}
extension UInt8 : FlipFlopSDK.MyWSArrayType {
}
extension Array where Element : FlipFlopSDK.MyWSArrayType, Element : Swift.UnsignedInteger {
  public func readUint16(offset: Swift.Int) -> Swift.UInt16
  public func readUint64(offset: Swift.Int) -> Swift.UInt64
  public func unmaskData(maskStart: Swift.Int, offset: Swift.Int, length: Swift.Int) -> Foundation.Data
}
public func writeUint16(_ buffer: inout [Swift.UInt8], offset: Swift.Int, value: Swift.UInt16)
public func writeUint32(_ buffer: inout [Swift.UInt8], offset: Swift.Int, value: Swift.UInt32)
public func writeUint64(_ buffer: inout [Swift.UInt8], offset: Swift.Int, value: Swift.UInt64)
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
@available(watchOS, unavailable)
public class WebSocketServer : FlipFlopSDK.Server, FlipFlopSDK.ConnectionDelegate {
  public var onEvent: ((FlipFlopSDK.ServerEvent) -> Swift.Void)?
  public init()
  public func start(address: Swift.String, port: Swift.UInt16) -> Swift.Error?
  public func didReceive(event: FlipFlopSDK.ServerEvent)
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
public class ServerConnection : FlipFlopSDK.Connection, FlipFlopSDK.HTTPServerDelegate, FlipFlopSDK.FramerEventClient, FlipFlopSDK.FrameCollectorDelegate, FlipFlopSDK.TransportEventClient {
  public var onEvent: ((FlipFlopSDK.ConnectionEvent) -> Swift.Void)?
  weak public var delegate: FlipFlopSDK.ConnectionDelegate?
  public func write(data: Foundation.Data, opcode: FlipFlopSDK.FrameOpCode)
  public func connectionChanged(state: FlipFlopSDK.ConnectionState)
  public func didReceive(event: FlipFlopSDK.HTTPEvent)
  public func frameProcessed(event: FlipFlopSDK.FrameEvent)
  public func didForm(event: FlipFlopSDK.FrameCollector.Event)
  public func decompress(data: Foundation.Data, isFinal: Swift.Bool) -> Foundation.Data?
  @objc deinit
}
extension AudioStreamBasicDescription : Swift.Equatable {
  public static func == (lhs: CoreAudioTypes.AudioStreamBasicDescription, rhs: CoreAudioTypes.AudioStreamBasicDescription) -> Swift.Bool
}
extension Logboard {
  public struct Data {
    public var date: Foundation.Date
    public var level: FlipFlopSDK.Logboard.Level
    public var identifier: Swift.String
    public var file: Swift.String
    public var line: Swift.Int
    public var function: Swift.String
    public var message: Swift.String
    public init?(_ data: Foundation.Data)
  }
}
extension Logboard.Data : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public protocol WebRTCStreamerDelegate : AnyObject {
  func onWebRTCConnected()
  func onWebRTCDisconnected()
  func onWebRTCStarted()
  func onWebRTCStopped()
  func onWebRTCError(notification: Foundation.Notification)
}
@objc @_hasMissingDesignatedInitializers open class WebRTCStreamer : ObjectiveC.NSObject {
  public var isStarted: Swift.Bool
  open func start(url: Swift.String, streamkey: Swift.String)
  open func stop()
  open func reset()
  open func switchCamera()
  @objc override dynamic public init()
  @objc deinit
}
public class WebRTCStreamerBuilder {
  public init()
  public func withCaptureSettings(_ fps: Swift.Int = 30, sessionPreset: FlipFlopSDK.Preset = Preset.hd1280x720, isVideoMirrored: Swift.Bool = false, continuousAutofocus: Swift.Bool = false, continuousExposure: Swift.Bool = false, preferredVideoStabilizationMode: AVFoundation.AVCaptureVideoStabilizationMode = AVCaptureVideoStabilizationMode.off) -> FlipFlopSDK.WebRTCStreamerBuilder
  public func withVideoSettings(_ bitrate: Swift.Int = 2000 * 1000, profileLevel: Swift.String = kVTProfileLevel_H264_Baseline_AutoLevel as String, maxKeyFrameIntervalDuration: Swift.Int = 2) -> FlipFlopSDK.WebRTCStreamerBuilder
  public func withAudioSettings(_ muted: Swift.Bool = false) -> FlipFlopSDK.WebRTCStreamerBuilder
  public func withView(_ view: UIKit.UIView) -> FlipFlopSDK.WebRTCStreamerBuilder
  public func withEnableAudio(_ enable: Swift.Bool) -> FlipFlopSDK.WebRTCStreamerBuilder
  public func withEnableVideo(_ enable: Swift.Bool, position: AVFoundation.AVCaptureDevice.Position) -> FlipFlopSDK.WebRTCStreamerBuilder
  public func build() -> FlipFlopSDK.WebRTCStreamer?
  @objc deinit
}
extension WebRTCStreamer {
  public typealias Builder = FlipFlopSDK.WebRTCStreamerBuilder
}
public struct DeviceUtil {
  public static func device(withPosition: AVFoundation.AVCaptureDevice.Position) -> AVFoundation.AVCaptureDevice?
  public static func device(withLocalizedName: Swift.String, mediaType: AVFoundation.AVMediaType) -> AVFoundation.AVCaptureDevice?
}
public protocol Running : AnyObject {
  var isRunning: FlipFlopSDK.Atomic<Swift.Bool> { get }
  func startRunning()
  func stopRunning()
}
public struct Config {
  public init(isDev: Swift.Bool)
  public init(apiServerURI: Swift.String, rtmpServerURI: Swift.String, webrtcServerURI: Swift.String, gossipServerURI: Swift.String)
}
@_hasMissingDesignatedInitializers @objc public class FlipFlop : ObjectiveC.NSObject {
  @objc public static var AppKey: Swift.String {
    @objc get
  }
  @objc public static var AppSecret: Swift.String {
    @objc get
  }
  @objc public var userID: Swift.String {
    @objc get
  }
  @objc public var userName: Swift.String {
    @objc get
  }
  @objc public var avatarProfileURL: Swift.String {
    @objc get
  }
  @objc deinit
  public static func setConfig(config: FlipFlopSDK.Config)
  @objc public static func initialize(appKey: Swift.String, appSecret: Swift.String)
  @objc public static func uninitialize()
  @objc public static func debug(level: Swift.Int)
  @objc public static func authentication(userID: Swift.String, userName: Swift.String, avatarProfileURL: Swift.String, onSuccess: ((FlipFlopSDK.FlipFlop) -> Swift.Void)?, onFailure: ((FlipFlopSDK.FFError) -> Swift.Void)?)
  public static func authentication(userID: Swift.String, userName: Swift.String, avatarProfileURL: Swift.String, completion: ((Swift.Result<FlipFlopSDK.FlipFlop, FlipFlopSDK.FFError>) -> Swift.Void)?)
  @objc public func updateUserInfo(userName: Swift.String? = nil, avatarProfileURL: Swift.String? = nil, onSuccess: (() -> Swift.Void)?, onFailure: ((FlipFlopSDK.FFError) -> Swift.Void)?)
  public func updateUserInfo(userName: Swift.String? = nil, avatarProfileURL: Swift.String? = nil, completion: ((Swift.Result<Swift.Void, FlipFlopSDK.FFError>) -> Swift.Void)?)
  @objc public static func getRTMPStreamer() -> FlipFlopSDK.FFStreamer
  @objc public static func getWebRTCStreamer() -> FlipFlopSDK.FFStreamer
  @objc public func getPlayer(video_key: Swift.String) -> FlipFlopSDK.FFPlayer
  @objc public func getConference(room: Swift.String) -> FlipFlopSDK.FFConference
  @objc public func getVideoListLoader(cursor: Swift.String?, count: Swift.Int, userID: Swift.String?, type: Swift.String?, state: Swift.String?) -> FlipFlopSDK.FFVideoListLoader
  public func getVideoListLoader(cursor: Swift.String? = nil, count: Swift.Int? = nil, userID: Swift.String? = nil, type: Swift.String? = nil, state: Swift.String? = nil) -> FlipFlopSDK.FFVideoListLoader
  public func createVideo(title: Swift.String? = nil, content: Swift.String? = nil, visibility: Swift.String? = nil, thumbnail_url: Swift.String? = nil, data: Swift.String? = nil, data2: Swift.String? = nil, source_type: Swift.Int? = nil, completion: ((Swift.Result<FlipFlopSDK.FFVideoInfo, FlipFlopSDK.FFError>) -> Swift.Void)?)
  public func endVideo(videokey: Swift.String, keepLive: Swift.Bool = false, completion: ((Swift.Result<FlipFlopSDK.FFVideoEnd, FlipFlopSDK.FFError>) -> Swift.Void)?)
  public func getVideo(videokey: Swift.String, completion: ((Swift.Result<FlipFlopSDK.FFVideoInfo, FlipFlopSDK.FFError>) -> Swift.Void)?)
  public func editVideo(videoKey: Swift.String, title: Swift.String? = nil, content: Swift.String? = nil, visibility: Swift.String? = nil, thumbnail_url: Swift.String? = nil, data: Swift.String? = nil, data2: Swift.String? = nil, completion: ((Swift.Result<FlipFlopSDK.FFVideoInfo, FlipFlopSDK.FFError>) -> Swift.Void)?)
  public func deleteVideo(videoKey: Swift.String, completion: ((Swift.Result<Swift.Void, FlipFlopSDK.FFError>) -> Swift.Void)?)
  public func getMyLives(within: Swift.Int? = nil, completion: ((Swift.Result<FlipFlopSDK.FFMyLives?, FlipFlopSDK.FFError>) -> Swift.Void)?)
  public func updateVideoSource(key: Swift.String, source_type: Swift.Int, completion: ((Swift.Result<FlipFlopSDK.FFVideoInfo?, FlipFlopSDK.FFError>) -> Swift.Void)?)
  public func uploadVideoThumbnail(videokey: Swift.String, image: UIKit.UIImage, jpegQuality: CoreGraphics.CGFloat = 0.7, completion: ((Swift.Result<Swift.String, FlipFlopSDK.FFError>) -> Swift.Void)?)
  public func uploadVideoThumbnail(videokey: Swift.String, data: Foundation.Data, completion: ((Swift.Result<Swift.String, FlipFlopSDK.FFError>) -> Swift.Void)?)
  @objc override dynamic public init()
}
public enum ConnectionState {
  case connected
  case waiting
  case cancelled
  case failed(Swift.Error?)
  case viability(Swift.Bool)
  case shouldReconnect(Swift.Bool)
  case receive(Foundation.Data)
}
public protocol TransportEventClient : AnyObject {
  func connectionChanged(state: FlipFlopSDK.ConnectionState)
}
public protocol Transport : AnyObject {
  func register(delegate: FlipFlopSDK.TransportEventClient)
  func connect(url: Foundation.URL, timeout: Swift.Double, certificatePinning: FlipFlopSDK.CertificatePinning?)
  func disconnect()
  func write(data: Foundation.Data, completion: @escaping ((Swift.Error?) -> ()))
  var usingTLS: Swift.Bool { get }
}
public enum FLVAVCPacketType : Swift.UInt8 {
  case seq
  case nal
  case eos
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public enum FLVFrameType : Swift.UInt8 {
  case key
  case inter
  case disposable
  case generated
  case command
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
extension UIColor {
  public func imageWithColor(width: CoreGraphics.CGFloat, height: CoreGraphics.CGFloat) -> UIKit.UIImage
}
extension CIImage {
  public class func image(width: CoreGraphics.CGFloat, height: CoreGraphics.CGFloat, color: UIKit.UIColor, cornerRadius: CoreGraphics.CGFloat) -> CoreImage.CIImage
  public class func alphaImage(width: CoreGraphics.CGFloat, height: CoreGraphics.CGFloat, color: UIKit.UIColor, cornerRadius: CoreGraphics.CGFloat, alpha: CoreGraphics.CGFloat) -> CoreImage.CIImage
}
@objc @_inheritsConvenienceInitializers open class HKView : UIKit.UIView {
  public static var defaultBackgroundColor: UIKit.UIColor
  @objc override dynamic open class var layerClass: Swift.AnyClass {
    @objc get
  }
  @objc override dynamic open var layer: AVFoundation.AVCaptureVideoPreviewLayer {
    @objc get
  }
  public var videoGravity: AVFoundation.AVLayerVideoGravity {
    get
    set
  }
  public var videoFormatDescription: CoreMedia.CMVideoFormatDescription? {
    get
  }
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
  @objc override dynamic open func awakeFromNib()
  open func attachStream(_ stream: FlipFlopSDK.NetStream?)
}
public enum FLVTagType : Swift.UInt8 {
  case audio
  case video
  case data
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public protocol FLVTag : Swift.CustomDebugStringConvertible {
  var tagType: FlipFlopSDK.FLVTagType { get set }
  var dataSize: Swift.UInt32 { get set }
  var timestamp: Swift.UInt32 { get set }
  var timestampExtended: Swift.UInt8 { get set }
  var streamId: Swift.UInt32 { get set }
  var offset: Swift.UInt64 { get set }
  init()
  mutating func readData(_ fileHandler: Foundation.FileHandle)
}
extension FLVTag {
  public var debugDescription: Swift.String {
    get
  }
}
public struct FLVDataTag : FlipFlopSDK.FLVTag {
  public var tagType: FlipFlopSDK.FLVTagType
  public var dataSize: Swift.UInt32
  public var timestamp: Swift.UInt32
  public var timestampExtended: Swift.UInt8
  public var streamId: Swift.UInt32
  public var offset: Swift.UInt64
  public init()
  public mutating func readData(_ fileHandler: Foundation.FileHandle)
}
public struct FLVAudioTag : FlipFlopSDK.FLVTag {
  public var tagType: FlipFlopSDK.FLVTagType
  public var dataSize: Swift.UInt32
  public var timestamp: Swift.UInt32
  public var timestampExtended: Swift.UInt8
  public var streamId: Swift.UInt32
  public var offset: Swift.UInt64
  public var codec: FlipFlopSDK.FLVAudioCodec
  public var soundRate: FlipFlopSDK.FLVSoundRate
  public var soundSize: FlipFlopSDK.FLVSoundSize
  public var soundType: FlipFlopSDK.FLVSoundType
  public init()
  public mutating func readData(_ fileHandler: Foundation.FileHandle)
}
public struct FLVVideoTag : FlipFlopSDK.FLVTag {
  public var tagType: FlipFlopSDK.FLVTagType
  public var dataSize: Swift.UInt32
  public var timestamp: Swift.UInt32
  public var timestampExtended: Swift.UInt8
  public var streamId: Swift.UInt32
  public var offset: Swift.UInt64
  public var frameType: FlipFlopSDK.FLVFrameType
  public var codec: FlipFlopSDK.FLVVideoCodec
  public var avcPacketType: FlipFlopSDK.FLVAVCPacketType
  public var compositionTime: Swift.Int32
  public init()
  public mutating func readData(_ fileHandler: Foundation.FileHandle)
}
@objc public protocol SwiftyGifDelegate {
  @objc optional func gifDidStart(sender: UIKit.UIImage)
  @objc optional func gifDidLoop(sender: UIKit.UIImage)
  @objc optional func gifDidStop(sender: UIKit.UIImage)
  @objc optional func gifURLDidFinish(sender: UIKit.UIImage)
  @objc optional func gifURLDidFail(sender: UIKit.UIImage, url: Foundation.URL, error: Swift.Error?)
}
public typealias GifLevelOfIntegrity = Swift.Float
extension Float {
  public static let highestNoFrameSkipping: FlipFlopSDK.GifLevelOfIntegrity
  public static let `default`: FlipFlopSDK.GifLevelOfIntegrity
  public static let lowForManyGifs: FlipFlopSDK.GifLevelOfIntegrity
  public static let lowForTooManyGifs: FlipFlopSDK.GifLevelOfIntegrity
  public static let superLowForSlideShow: FlipFlopSDK.GifLevelOfIntegrity
}
extension UIImage {
  convenience public init?(imageData: Foundation.Data, levelOfIntegrity: FlipFlopSDK.GifLevelOfIntegrity = .default) throws
  convenience public init?(imageName: Swift.String, levelOfIntegrity: FlipFlopSDK.GifLevelOfIntegrity = .default) throws
}
extension UIImage {
  convenience public init(gifData: Foundation.Data, levelOfIntegrity: FlipFlopSDK.GifLevelOfIntegrity = .default) throws
  convenience public init(gifName: Swift.String, levelOfIntegrity: FlipFlopSDK.GifLevelOfIntegrity = .default) throws
  public func setGifFromData(_ data: Foundation.Data, levelOfIntegrity: FlipFlopSDK.GifLevelOfIntegrity) throws
  public func setGif(_ name: Swift.String) throws
  public func framesCount() -> Swift.Int
  public func setGif(_ name: Swift.String, levelOfIntegrity: FlipFlopSDK.GifLevelOfIntegrity) throws
  public func clear()
}
extension UIImage {
  public var imageSource: ImageIO.CGImageSource? {
    get
    set
  }
  public var displayRefreshFactor: Swift.Int? {
    get
    set
  }
  public var imageSize: Swift.Int? {
    get
    set
  }
  public var imageCount: Swift.Int? {
    get
    set
  }
  public var displayOrder: [Swift.Int]? {
    get
    set
  }
  public var imageData: Foundation.Data? {
    get
    set
  }
  public var delegate: FlipFlopSDK.SwiftyGifDelegate? {
    get
    set
  }
}
@objc @_inheritsConvenienceInitializers public class SynchronousOperation : FlipFlopSDK.ConcurrentOperation {
  @objc override dynamic public var isAsynchronous: Swift.Bool {
    @objc get
  }
  override public func finish(success: Swift.Bool = true)
  @objc override dynamic public func cancel()
  override public func execute()
  override public init(name: Swift.String? = super, executionBlock: ((FlipFlopSDK.ConcurrentOperation) -> Swift.Void)? = super)
  @objc deinit
}
@objc open class ConcurrentOperation : Foundation.Operation {
  public var executionBlock: ((FlipFlopSDK.ConcurrentOperation) -> Swift.Void)?
  @objc override dynamic open var isAsynchronous: Swift.Bool {
    @objc get
  }
  @objc override dynamic open var isExecuting: Swift.Bool {
    @objc get
  }
  @objc override dynamic open var isFinished: Swift.Bool {
    @objc get
  }
  open var progress: Swift.Int {
    get
    set
  }
  @available(*, deprecated, renamed: "success")
  open var hasFailed: Swift.Bool {
    get
  }
  open var success: Swift.Bool
  open var maximumRetries: Swift.Int
  open var currentAttempt: Swift.Int {
    get
  }
  open var manualRetry: Swift.Bool
  public init(name: Swift.String? = nil, executionBlock: ((FlipFlopSDK.ConcurrentOperation) -> Swift.Void)? = nil)
  @objc override dynamic open func start()
  open func retry()
  open func execute()
  @available(*, deprecated, renamed: "finish(success:)")
  open func finish(_ hasFailed: Swift.Bool)
  open func finish(success: Swift.Bool = true)
  open func pause()
  open func resume()
  @objc override dynamic public init()
  @objc deinit
}
extension ConcurrentOperation {
  public func addToSharedQueuer()
  public func addToQueue(_ queue: FlipFlopSDK.Queuer)
}
public class ConsoleAppender : FlipFlopSDK.LogboardAppender {
  public init()
  public func append(_ logboard: FlipFlopSDK.Logboard, level: FlipFlopSDK.Logboard.Level, message: [Any], file: Swift.StaticString, function: Swift.StaticString, line: Swift.Int)
  public func append(_ logboard: FlipFlopSDK.Logboard, level: FlipFlopSDK.Logboard.Level, format: Swift.String, arguments: Swift.CVarArg, file: Swift.StaticString, function: Swift.StaticString, line: Swift.Int)
  @objc deinit
}
public enum VideoFilter {
  case none
  case sephia(value: Swift.Float)
  case blendMaks(overlayImage: CoreImage.CIImage, maskImage: CoreImage.CIImage)
  case sourceOverComposit(overlayImage: CoreImage.CIImage)
  case colorOverlay(color: UIKit.UIColor)
  case custom(effect: FlipFlopSDK.VideoEffect)
}
public class Logboard {
  public static let dateFormatter: Foundation.DateFormatter
  public enum Level : Swift.Int, Swift.CustomStringConvertible {
    case trace
    case debug
    case info
    case warn
    case error
    public init?(string: Swift.String)
    public var description: Swift.String {
      get
    }
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public static func with(_ identifier: Swift.String) -> FlipFlopSDK.Logboard
  final public let identifier: Swift.String
  public var level: FlipFlopSDK.Logboard.Level
  public var appender: FlipFlopSDK.LogboardAppender
  public init(_ identifier: Swift.String)
  public func isEnabledFor(level: FlipFlopSDK.Logboard.Level) -> Swift.Bool
  public func trace(_ message: Any..., file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.Int = #line)
  public func trace(format: Swift.String, arguments: Swift.CVarArg, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.Int = #line)
  public func debug(_ message: Any..., file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.Int = #line)
  public func debug(format: Swift.String, arguments: Swift.CVarArg, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.Int = #line)
  public func info(_ message: Any..., file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.Int = #line)
  public func info(format: Swift.String, arguments: Swift.CVarArg, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.Int = #line)
  public func warn(_ message: Any..., file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.Int = #line)
  public func warn(format: Swift.String, arguments: Swift.CVarArg, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.Int = #line)
  public func error(_ message: Any..., file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.Int = #line)
  public func error(format: Swift.String, arguments: Swift.CVarArg, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.Int = #line)
  @objc deinit
}
public struct MachUtil {
  public static let nanosPerUsec: Swift.UInt64
  public static let nanosPerMsec: Swift.UInt64
  public static let nanosPerSec: Swift.UInt64
  public static func nanosToAbs(_ nanos: Swift.UInt64) -> Swift.UInt64
  public static func absToNanos(_ abs: Swift.UInt64) -> Swift.UInt64
}
public protocol WebRTCPlayerDelegate : AnyObject {
  func onStarted(player: FlipFlopSDK.WebRTCPlayer)
  func onStopped(player: FlipFlopSDK.WebRTCPlayer)
  func onCompleted(player: FlipFlopSDK.WebRTCPlayer)
  func onError(player: FlipFlopSDK.WebRTCPlayer, error: Foundation.Notification)
}
@objc open class WebRTCPlayer : ObjectiveC.NSObject {
  public var isStarted: Swift.Bool
  public init(url: Foundation.URL, streamkey: Swift.String, view: UIKit.UIView, delegate: FlipFlopSDK.WebRTCPlayerDelegate?)
  open func start()
  open func stop()
  @objc override dynamic public init()
  @objc deinit
}
public struct Atomic<A> {
  public var value: A {
    get
  }
  public init(_ value: A)
  public mutating func mutate(_ transform: (inout A) -> Swift.Void)
}
public enum ReachabilityError : Swift.Error {
  case failedToCreateWithAddress(Darwin.sockaddr, Swift.Int32)
  case failedToCreateWithHostname(Swift.String, Swift.Int32)
  case unableToSetCallback(Swift.Int32)
  case unableToSetDispatchQueue(Swift.Int32)
  case unableToGetFlags(Swift.Int32)
}
extension NSNotification.Name {
  public static let reachabilityChanged: Foundation.Notification.Name
}
public class Reachability {
  public typealias NetworkReachable = (FlipFlopSDK.Reachability) -> ()
  public typealias NetworkUnreachable = (FlipFlopSDK.Reachability) -> ()
  public enum Connection : Swift.CustomStringConvertible {
    case unavailable, wifi, cellular
    public var description: Swift.String {
      get
    }
    public static func == (a: FlipFlopSDK.Reachability.Connection, b: FlipFlopSDK.Reachability.Connection) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var whenReachable: FlipFlopSDK.Reachability.NetworkReachable?
  public var whenUnreachable: FlipFlopSDK.Reachability.NetworkUnreachable?
  public var allowsCellularConnection: Swift.Bool
  public var notificationCenter: Foundation.NotificationCenter
  public var connection: FlipFlopSDK.Reachability.Connection {
    get
  }
  required public init(reachabilityRef: SystemConfiguration.SCNetworkReachability, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main)
  convenience public init(hostname: Swift.String, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main) throws
  convenience public init(queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main) throws
  @objc deinit
}
extension Reachability {
  public func startNotifier() throws
  public func stopNotifier()
  public var description: Swift.String {
    get
  }
}
@objc public protocol FFPlayerDelegate {
  @objc func onPrepared(player: FlipFlopSDK.FFPlayer)
  @objc func onStarted(player: FlipFlopSDK.FFPlayer)
  @objc func onPaused(player: FlipFlopSDK.FFPlayer)
  @objc func onStopped(player: FlipFlopSDK.FFPlayer)
  @objc func onCompleted(player: FlipFlopSDK.FFPlayer)
  @objc func onProgressUpdated(player: FlipFlopSDK.FFPlayer, sec: Swift.Float64)
  @objc func onError(player: FlipFlopSDK.FFPlayer, error: FlipFlopSDK.FFError)
  @objc func onChatMessgeReceived(player: FlipFlopSDK.FFPlayer, message: FlipFlopSDK.FFMessage)
  @objc func onChatStatReceived(player: FlipFlopSDK.FFPlayer, stat: FlipFlopSDK.FFStat)
  @objc func onBackground(player: FlipFlopSDK.FFPlayer)
  @objc func onForeground(player: FlipFlopSDK.FFPlayer)
}
@_hasMissingDesignatedInitializers @objc public class FFPlayer : ObjectiveC.NSObject {
  @objc weak public var delegate: FlipFlopSDK.FFPlayerDelegate?
  @objc public var duration: Swift.Float64 {
    @objc get
  }
  @objc public var isMuted: Swift.Bool {
    @objc get
    @objc set
  }
  @objc public func prepare(view: UIKit.UIView)
  @objc public func start()
  @objc public func pause()
  @objc public func resume()
  @objc public func stop()
  @objc public func seekTo(sec: Swift.Float64, exactly: Swift.Bool = false, completion: ((Swift.Float64) -> Swift.Void)?)
  @objc public func startPIP()
  @objc public func stopPIP()
  @objc public func reset()
  @objc public func sendMessage(text: Swift.String, data: Swift.String? = nil, customType: Swift.String? = nil)
  @objc public func sendWhispher(receiver: Swift.String, text: Swift.String, data: Swift.String? = nil, customType: Swift.String? = nil)
  @objc override dynamic public init()
  @objc deinit
}
extension FFPlayer : FlipFlopSDK.HLSPlayerDelegate {
  public func onProgressUpdated(player: FlipFlopSDK.HLSPlayer, seconds: Swift.Float64)
  public func onPrepared(player: FlipFlopSDK.HLSPlayer)
  public func onPaused(player: FlipFlopSDK.HLSPlayer)
  public func onStarted(player: FlipFlopSDK.HLSPlayer)
  public func onStopped(player: FlipFlopSDK.HLSPlayer)
  public func onCompleted(player: FlipFlopSDK.HLSPlayer)
  public func onError(player: FlipFlopSDK.HLSPlayer, error: Swift.Error)
  public func onVideoResolutionSize(player: FlipFlopSDK.HLSPlayer, size: CoreGraphics.CGSize)
  public func onBackground(player: FlipFlopSDK.HLSPlayer)
  public func onForeground(player: FlipFlopSDK.HLSPlayer)
}
extension FFPlayer : FlipFlopSDK.WebRTCPlayerDelegate {
  public func onStarted(player: FlipFlopSDK.WebRTCPlayer)
  public func onStopped(player: FlipFlopSDK.WebRTCPlayer)
  public func onCompleted(player: FlipFlopSDK.WebRTCPlayer)
  public func onError(player: FlipFlopSDK.WebRTCPlayer, error: Foundation.Notification)
}
public class WSCompression : FlipFlopSDK.CompressionHandler {
  public init()
  public func load(headers: [Swift.String : Swift.String])
  public func decompress(data: Foundation.Data, isFinal: Swift.Bool) -> Foundation.Data?
  public func compress(data: Foundation.Data) -> Foundation.Data?
  @objc deinit
}
public protocol ScreenCaptureOutputPixelBufferDelegate : AnyObject {
  func didSet(size: CoreGraphics.CGSize)
  func output(pixelBuffer: CoreVideo.CVPixelBuffer, withPresentationTime: CoreMedia.CMTime)
}
public protocol CustomCaptureSession : FlipFlopSDK.Running {
  var attributes: [Foundation.NSString : ObjectiveC.NSObject] { get }
  var delegate: FlipFlopSDK.ScreenCaptureOutputPixelBufferDelegate? { get set }
}
@objc open class ScreenCaptureSession : ObjectiveC.NSObject, FlipFlopSDK.CustomCaptureSession {
  public var enabledScale: Swift.Bool
  public var frameInterval: Swift.Int
  public var attributes: [Foundation.NSString : ObjectiveC.NSObject] {
    get
  }
  weak public var delegate: FlipFlopSDK.ScreenCaptureOutputPixelBufferDelegate?
  public var isRunning: FlipFlopSDK.Atomic<Swift.Bool> {
    get
  }
  public var afterScreenUpdates: Swift.Bool
  public init(shared: UIKit.UIApplication)
  public init(viewToCapture: UIKit.UIView)
  @objc public func onScreen(_ displayLink: QuartzCore.CADisplayLink)
  open func onScreenProcess(_ displayLink: QuartzCore.CADisplayLink)
  @objc override dynamic public init()
  @objc deinit
}
extension ScreenCaptureSession : FlipFlopSDK.Running {
  public func startRunning()
  public func stopRunning()
}
@objc public enum FFMessageType : Swift.Int {
  case msg
  case join
  case leave
  case admin
  case stat
  case whisper
  case command
  case unknown
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers @objc public class FFStat : ObjectiveC.NSObject {
  @objc public var participantCount: Swift.Int64
  @objc public var totalUserCount: Swift.Int64
  @objc override dynamic public init()
  @objc deinit
}
extension FFStat {
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
}
@_hasMissingDesignatedInitializers @objc public class FFMessage : ObjectiveC.NSObject {
  @objc final public let type: Swift.String
  @objc final public let id: Swift.String
  @objc final public let message: Swift.String
  @objc final public let createAt: Swift.UInt64
  @objc final public let userID: Swift.String
  @objc public var userName: Swift.String
  @objc public var avatarProfileURL: Swift.String?
  @objc final public let data: Swift.String?
  @objc final public let customType: Swift.String?
  @objc override dynamic public init()
  @objc deinit
}
extension FFMessage {
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
}
@_hasMissingDesignatedInitializers @objc public class FFError : ObjectiveC.NSObject, Swift.Error {
  @objc final public let code: Swift.Int
  @objc final public let message: Swift.String
  @objc override dynamic public init()
  @objc deinit
}
@objc public protocol FFStreamConfig {
  @objc var width: Swift.Int { get set }
  @objc var height: Swift.Int { get set }
  @objc var videoBitrate: Swift.Int { get set }
  @objc var keyFrameInterval: Swift.Int { get set }
  @objc var fps: Swift.Int { get set }
  @objc var sampleRate: Swift.Int { get set }
  @objc var audioBitrate: Swift.Int { get set }
  @objc var cameraPos: AVFoundation.AVCaptureDevice.Position { get set }
}
public struct FFPlan : Swift.CustomStringConvertible {
  public let name: Swift.String
  public let channel_count: Swift.Int
  public let retention_period: Swift.Int
  public let vod_count: Swift.Int
  public let expose_goods_count: Swift.Int
  public let resolutions: Swift.String?
  public let support: Swift.Bool
  public var description: Swift.String {
    get
  }
}
public struct FFMyPlan : Swift.CustomStringConvertible {
  public let member_id: Swift.Int64
  public let plan: FlipFlopSDK.FFPlan
  public let started_at: Swift.Int64
  public let ended_at: Swift.Int64?
  public var description: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers @objc public class FFVideoEnd : ObjectiveC.NSObject {
  @objc final public let like_count: Swift.UInt64
  @objc final public let total_message_count: Swift.UInt64
  @objc final public let total_watcher_count: Swift.UInt64
  @objc final public let duration: Swift.UInt64
  @objc final public let created_at: Swift.UInt64
  @objc final public let vod_url: Swift.String
  @objc override dynamic public init()
  @objc deinit
}
@_hasMissingDesignatedInitializers @objc public class FFStreamEvent : ObjectiveC.NSObject {
  @objc final public let id: Swift.Int64
  @objc final public let video_key: Swift.String
  @objc final public let stream_key: Swift.String
  @objc final public let state: Swift.String
  @objc final public let created_at: Swift.UInt64
  @objc override dynamic public init()
  @objc deinit
}
@_hasMissingDesignatedInitializers @objc public class FFMyLives : ObjectiveC.NSObject {
  @objc final public let video: FlipFlopSDK.FFVideoInfo?
  @objc final public let stream_event: FlipFlopSDK.FFStreamEvent?
  @objc final public let available_live_count: Swift.Int
  @objc override dynamic public init()
  @objc deinit
}
extension FFMyLives {
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
}
@_hasMissingDesignatedInitializers @objc public class FFVideoInfo : ObjectiveC.NSObject {
  @objc final public let video_key: Swift.String
  @objc final public let type: Swift.String
  @objc final public let user_id: Swift.String
  @objc final public let user_name: Swift.String
  @objc final public let user_avatar_url: Swift.String
  @objc final public let title: Swift.String
  @objc final public let content: Swift.String
  @objc final public let state: Swift.String
  @objc final public let duration: Swift.UInt64
  @objc final public let visibility: Swift.String
  @objc final public let muted: Swift.Bool
  @objc final public let locked: Swift.Bool
  @objc final public let url: Swift.String
  @objc final public let thumbnail_url: Swift.String
  @objc final public let stream_key: Swift.String?
  @objc final public let live_key: Swift.String?
  @objc final public let data: Swift.String
  @objc final public let data2: Swift.String
  @objc final public let watch_count: Swift.UInt64
  @objc final public let heart_count: Swift.UInt64
  @objc final public let view_count: Swift.UInt64
  @objc final public let like_count: Swift.UInt64
  @objc final public let liked_by_me: Swift.Bool
  @objc final public let created_at: Swift.UInt64
  @objc override dynamic public init()
  @objc deinit
}
extension FFVideoInfo {
  public func getGoods<T>() -> T? where T : Swift.Decodable
  @objc dynamic public func getGoods() -> Swift.String
}
public protocol FFCursorLoader {
  associatedtype Response
  var cursor: Swift.String? { get set }
  var count: Swift.Int? { get set }
  func reset()
  func next(completion: ((Swift.Result<Self.Response, Swift.Error>) -> Swift.Void)?)
}
@_hasMissingDesignatedInitializers @objc public class FFVideoListLoader : ObjectiveC.NSObject, FlipFlopSDK.FFCursorLoader {
  public typealias Response = [FlipFlopSDK.FFVideoInfo]
  public var cursor: Swift.String?
  public var count: Swift.Int?
  @objc public func reset()
  @objc public func next(onSuccess: (([FlipFlopSDK.FFVideoInfo]) -> Swift.Void)?, onFailure: ((Swift.Error) -> Swift.Void)?)
  public func next(completion: ((Swift.Result<FlipFlopSDK.FFVideoListLoader.Response, Swift.Error>) -> Swift.Void)?)
  @objc override dynamic public init()
  @objc deinit
}
@objc open class MTHKView : MetalKit.MTKView {
  open var isMirrored: Swift.Bool
  open var videoGravity: AVFoundation.AVLayerVideoGravity
  open var videoFormatDescription: CoreMedia.CMVideoFormatDescription? {
    get
  }
  @objc dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init(coder aDecoder: Foundation.NSCoder)
  @objc override dynamic open func awakeFromNib()
  open func attachStream(_ stream: FlipFlopSDK.NetStream?)
  @objc override dynamic public init(frame frameRect: CoreGraphics.CGRect, device: Metal.MTLDevice?)
  @objc deinit
}
extension MTHKView : MetalKit.MTKViewDelegate {
  @objc dynamic public func mtkView(_ view: MetalKit.MTKView, drawableSizeWillChange size: CoreGraphics.CGSize)
  @objc dynamic public func draw(in view: MetalKit.MTKView)
}
public class FoundationHTTPHandler : FlipFlopSDK.HTTPHandler {
  public init()
  public func convert(request: Foundation.URLRequest) -> Foundation.Data
  public func parse(data: Foundation.Data) -> Swift.Int
  public func register(delegate: FlipFlopSDK.HTTPHandlerDelegate)
  @objc deinit
}
public protocol KeyPathRepresentable : Swift.CaseIterable, Swift.Hashable {
  var keyPath: Swift.AnyKeyPath { get }
}
public class Setting<T, Key> : Swift.ExpressibleByDictionaryLiteral where T : AnyObject, Key : FlipFlopSDK.KeyPathRepresentable {
  public typealias Key = Key
  public typealias Value = Any
  required public init(dictionaryLiteral elements: (Key, Any)...)
  public subscript(key: Key) -> Any? {
    get
    set
  }
  @objc deinit
}
extension Setting : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public struct Scheduler {
  public var timer: Dispatch.DispatchSourceTimer {
    get
  }
  public var deadline: Dispatch.DispatchTime {
    get
  }
  public var repeating: Dispatch.DispatchTimeInterval {
    get
  }
  public var qualityOfService: Dispatch.DispatchQoS {
    get
  }
  public var handler: (() -> Swift.Void)? {
    get
  }
  public init(deadline: Dispatch.DispatchTime, repeating: Dispatch.DispatchTimeInterval, qualityOfService: Dispatch.DispatchQoS = .default, handler: (() -> Swift.Void)? = nil)
  public mutating func setHandler(_ handler: @escaping () -> Swift.Void)
}
public struct SoundTransform {
  public static let defaultVolume: Swift.Float
  public static let defaultPan: Swift.Float
  public var volume: Swift.Float
  public var pan: Swift.Float
}
extension SoundTransform : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@objc @_inheritsConvenienceInitializers open class NetSocket : ObjectiveC.NSObject {
  public static let defaultTimeout: Swift.Int
  public static let defaultWindowSizeC: Swift.Int
  open var inputBuffer: Foundation.Data
  open var timeout: Swift.Int
  open var connected: Swift.Bool
  open var windowSizeC: Swift.Int
  open var totalBytesIn: FlipFlopSDK.Atomic<Swift.Int64>
  open var qualityOfService: Dispatch.DispatchQoS
  open var securityLevel: Foundation.StreamSocketSecurityLevel
  open var totalBytesOut: FlipFlopSDK.Atomic<Swift.Int64> {
    get
  }
  open var queueBytesOut: FlipFlopSDK.Atomic<Swift.Int64> {
    get
  }
  @objc deinit
  public func connect(withName: Swift.String, port: Swift.Int)
  @discardableResult
  public func doOutput(data: Foundation.Data, locked: Swift.UnsafeMutablePointer<Swift.UInt32>? = nil) -> Swift.Int
  open func close()
  open func listen()
  @objc override dynamic public init()
}
extension NetSocket : Foundation.StreamDelegate {
  @objc dynamic public func stream(_ aStream: Foundation.Stream, handle eventCode: Foundation.Stream.Event)
}
public class OperationState : Swift.Codable {
  public var name: Swift.String
  public var progress: Swift.Int
  public var dependencies: [Swift.String]
  public init(name: Swift.String, progress: Swift.Int, dependencies: [Swift.String])
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
  required public init(from decoder: Swift.Decoder) throws
}
extension OperationState : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public protocol VideoEncoderDelegate : AnyObject {
  func didSetFormatDescription(video formatDescription: CoreMedia.CMFormatDescription?)
  func sampleOutput(video sampleBuffer: CoreMedia.CMSampleBuffer)
}
@_hasMissingDesignatedInitializers final public class H264Encoder {
  public enum Option : Swift.String, FlipFlopSDK.KeyPathRepresentable, Swift.CaseIterable {
    case muted
    case width
    case height
    case bitrate
    case profileLevel
    case maxKeyFrameIntervalDuration
    case scalingMode
    public var keyPath: Swift.AnyKeyPath {
      get
    }
    public init?(rawValue: Swift.String)
    public typealias AllCases = [FlipFlopSDK.H264Encoder.Option]
    public typealias RawValue = Swift.String
    public static var allCases: [FlipFlopSDK.H264Encoder.Option] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  public static let defaultWidth: Swift.Int32
  public static let defaultHeight: Swift.Int32
  public static let defaultBitrate: Swift.UInt32
  public static let defaultScalingMode: FlipFlopSDK.ScalingMode
  final public var settings: FlipFlopSDK.Setting<FlipFlopSDK.H264Encoder, FlipFlopSDK.H264Encoder.Option> {
    get
    set
  }
  final public var isRunning: FlipFlopSDK.Atomic<Swift.Bool> {
    get
  }
  @objc deinit
}
extension H264Encoder : FlipFlopSDK.Running {
  final public func startRunning()
  final public func stopRunning()
}
extension DeviceUtil {
  public static func videoOrientation(by notification: Foundation.Notification) -> AVFoundation.AVCaptureVideoOrientation?
  public static func videoOrientation(by orientation: UIKit.UIDeviceOrientation) -> AVFoundation.AVCaptureVideoOrientation?
  public static func videoOrientation(by orientation: UIKit.UIInterfaceOrientation) -> AVFoundation.AVCaptureVideoOrientation?
}
@objc @_inheritsConvenienceInitializers open class NetStream : ObjectiveC.NSObject {
  final public let lockQueue: Dispatch.DispatchQueue
  open var mixer: FlipFlopSDK.AVMixer {
    get
  }
  open var metadata: [Swift.String : Any?]
  open var context: CoreImage.CIContext? {
    get
    set
  }
  open var torch: Swift.Bool {
    get
    set
  }
  open var audioSettings: FlipFlopSDK.Setting<FlipFlopSDK.AudioCodec, FlipFlopSDK.AudioCodec.Option> {
    get
    set
  }
  open var videoSettings: FlipFlopSDK.Setting<FlipFlopSDK.H264Encoder, FlipFlopSDK.H264Encoder.Option> {
    get
    set
  }
  open var captureSettings: FlipFlopSDK.Setting<FlipFlopSDK.AVMixer, FlipFlopSDK.AVMixer.Option> {
    get
    set
  }
  open var recorderSettings: [AVFoundation.AVMediaType : [Swift.String : Any]] {
    get
    set
  }
  @objc deinit
  open func attachCamera(_ camera: AVFoundation.AVCaptureDevice?, onError: ((Foundation.NSError) -> Swift.Void)? = nil)
  open func attachAudio(_ audio: AVFoundation.AVCaptureDevice?, automaticallyConfiguresApplicationAudioSession: Swift.Bool = false, onError: ((Foundation.NSError) -> Swift.Void)? = nil)
  open func setPointOfInterest(focus: CoreGraphics.CGPoint)
  open func setPointOfInterest(exposure: CoreGraphics.CGPoint)
  open func setExposureTargetBias(bias: Swift.Float)
  open func appendSampleBuffer(_ sampleBuffer: CoreMedia.CMSampleBuffer, withType: AVFoundation.AVMediaType, options: [ObjectiveC.NSObject : Swift.AnyObject]? = nil)
  open func registerVideoEffect(_ effect: FlipFlopSDK.VideoEffect) -> Swift.Bool
  open func unregisterVideoEffect(_ effect: FlipFlopSDK.VideoEffect) -> Swift.Bool
  open func registerAudioEffect(_ effect: FlipFlopSDK.AudioEffect) -> Swift.Bool
  open func unregisterAudioEffect(_ effect: FlipFlopSDK.AudioEffect) -> Swift.Bool
  open func dispose()
  @objc override dynamic public init()
}
public protocol AVRecorderDelegate : AnyObject {
  var moviesDirectory: Foundation.URL { get }
  func rotateFile(_ recorder: FlipFlopSDK.AVRecorder, withPresentationTimeStamp: CoreMedia.CMTime, mediaType: AVFoundation.AVMediaType)
  func getPixelBufferAdaptor(_ recorder: FlipFlopSDK.AVRecorder, withWriterInput: AVFoundation.AVAssetWriterInput?) -> AVFoundation.AVAssetWriterInputPixelBufferAdaptor?
  func getWriterInput(_ recorder: FlipFlopSDK.AVRecorder, mediaType: AVFoundation.AVMediaType, sourceFormatHint: CoreMedia.CMFormatDescription?) -> AVFoundation.AVAssetWriterInput?
  func didStartRunning(_ recorder: FlipFlopSDK.AVRecorder)
  func didStopRunning(_ recorder: FlipFlopSDK.AVRecorder)
  func didFinishWriting(_ recorder: FlipFlopSDK.AVRecorder)
}
@objc @_inheritsConvenienceInitializers open class AVRecorder : ObjectiveC.NSObject {
  public static let defaultOutputSettings: [AVFoundation.AVMediaType : [Swift.String : Any]]
  open var writer: AVFoundation.AVAssetWriter?
  open var fileName: Swift.String?
  weak open var delegate: FlipFlopSDK.AVRecorderDelegate?
  open var writerInputs: [AVFoundation.AVMediaType : AVFoundation.AVAssetWriterInput]
  open var outputSettings: [AVFoundation.AVMediaType : [Swift.String : Any]]
  open var pixelBufferAdaptor: AVFoundation.AVAssetWriterInputPixelBufferAdaptor?
  final public let lockQueue: Dispatch.DispatchQueue
  public var isRunning: FlipFlopSDK.Atomic<Swift.Bool> {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
extension AVRecorder : FlipFlopSDK.Running {
  public func startRunning()
  public func stopRunning()
}
@objc open class DefaultAVRecorderDelegate : ObjectiveC.NSObject {
  public enum FileType {
    case mp4
    case mov
    public var AVFileType: AVFoundation.AVFileType {
      get
    }
    public var fileExtension: Swift.String {
      get
    }
    public static func == (a: FlipFlopSDK.DefaultAVRecorderDelegate.FileType, b: FlipFlopSDK.DefaultAVRecorderDelegate.FileType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let shared: FlipFlopSDK.DefaultAVRecorderDelegate
  open var duration: Swift.Int64
  open var dateFormat: Swift.String
  public var fileType: FlipFlopSDK.DefaultAVRecorderDelegate.FileType {
    get
  }
  open var moviesDirectory: Foundation.URL {
    get
    set
  }
  public init(fileType: FlipFlopSDK.DefaultAVRecorderDelegate.FileType = .mp4)
  @objc override dynamic public init()
  @objc deinit
}
@objc extension DefaultAVRecorderDelegate : FlipFlopSDK.AVRecorderDelegate {
  @objc dynamic open func rotateFile(_ recorder: FlipFlopSDK.AVRecorder, withPresentationTimeStamp: CoreMedia.CMTime, mediaType: AVFoundation.AVMediaType)
  @objc dynamic open func getPixelBufferAdaptor(_ recorder: FlipFlopSDK.AVRecorder, withWriterInput: AVFoundation.AVAssetWriterInput?) -> AVFoundation.AVAssetWriterInputPixelBufferAdaptor?
  @objc dynamic open func getWriterInput(_ recorder: FlipFlopSDK.AVRecorder, mediaType: AVFoundation.AVMediaType, sourceFormatHint: CoreMedia.CMFormatDescription?) -> AVFoundation.AVAssetWriterInput?
  @objc dynamic open func didFinishWriting(_ recorder: FlipFlopSDK.AVRecorder)
  @objc dynamic open func didStartRunning(_ recorder: FlipFlopSDK.AVRecorder)
  @objc dynamic open func didStopRunning(_ recorder: FlipFlopSDK.AVRecorder)
}
public enum SecurityErrorCode : Swift.UInt16 {
  case acceptFailed
  case pinningFailed
  public init?(rawValue: Swift.UInt16)
  public typealias RawValue = Swift.UInt16
  public var rawValue: Swift.UInt16 {
    get
  }
}
public enum PinningState {
  case success
  case failed(CoreFoundation.CFError?)
}
public protocol CertificatePinning : AnyObject {
  func evaluateTrust(trust: Security.SecTrust, domain: Swift.String?, completion: ((FlipFlopSDK.PinningState) -> ()))
}
public protocol HeaderValidator : AnyObject {
  func validate(headers: [Swift.String : Swift.String], key: Swift.String) -> Swift.Error?
}
extension UIImage {
  public func rounded(radius: CoreGraphics.CGFloat) -> UIKit.UIImage
  public func roundedImageWithBorder(cornerRadius: CoreGraphics.CGFloat, width: CoreGraphics.CGFloat, color: UIKit.UIColor) -> UIKit.UIImage?
  public func alpha(_ value: CoreGraphics.CGFloat) -> UIKit.UIImage
  public func scalePreservingAspectRatio(targetSize: CoreGraphics.CGSize, scale: CoreGraphics.CGFloat) -> UIKit.UIImage
}
public enum FLVVideoCodec : Swift.UInt8 {
  case sorensonH263
  case screen1
  case on2VP6
  case on2VP6Alpha
  case screen2
  case avc
  case unknown
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public protocol LogboardAppender {
  func append(_ logboard: FlipFlopSDK.Logboard, level: FlipFlopSDK.Logboard.Level, message: [Any], file: Swift.StaticString, function: Swift.StaticString, line: Swift.Int)
  func append(_ logboard: FlipFlopSDK.Logboard, level: FlipFlopSDK.Logboard.Level, format: Swift.String, arguments: Swift.CVarArg, file: Swift.StaticString, function: Swift.StaticString, line: Swift.Int)
}
@objc @_inheritsConvenienceInitializers @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public class NativeEngine : ObjectiveC.NSObject, FlipFlopSDK.Engine, Foundation.URLSessionDataDelegate, Foundation.URLSessionWebSocketDelegate {
  public func register(delegate: FlipFlopSDK.EngineDelegate)
  public func start(request: Foundation.URLRequest)
  public func stop(closeCode: Swift.UInt16)
  public func forceStop()
  public func write(string: Swift.String, completion: (() -> ())?)
  public func write(data: Foundation.Data, opcode: FlipFlopSDK.FrameOpCode, completion: (() -> ())?)
  @objc public func urlSession(_ session: Foundation.URLSession, webSocketTask: Foundation.URLSessionWebSocketTask, didOpenWithProtocol protocol: Swift.String?)
  @objc public func urlSession(_ session: Foundation.URLSession, webSocketTask: Foundation.URLSessionWebSocketTask, didCloseWith closeCode: Foundation.URLSessionWebSocketTask.CloseCode, reason: Foundation.Data?)
  @objc override dynamic public init()
  @objc deinit
}
public enum HKPictureInPicureControllerPosition {
  case topLeft
  case topRight
  case bottomRight
  case bottomLeft
  public static func == (a: FlipFlopSDK.HKPictureInPicureControllerPosition, b: FlipFlopSDK.HKPictureInPicureControllerPosition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol FrameCollectorDelegate : AnyObject {
  func didForm(event: FlipFlopSDK.FrameCollector.Event)
  func decompress(data: Foundation.Data, isFinal: Swift.Bool) -> Foundation.Data?
}
@_hasMissingDesignatedInitializers public class FrameCollector {
  public enum Event {
    case text(Swift.String)
    case binary(Foundation.Data)
    case pong(Foundation.Data?)
    case ping(Foundation.Data?)
    case error(Swift.Error)
    case closed(Swift.String, Swift.UInt16)
  }
  public func add(frame: FlipFlopSDK.Frame)
  @objc deinit
}
public enum ScalingMode : Swift.String {
  case normal
  case letterbox
  case cropSourceToCleanAperture
  case trim
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension Data {
}
extension HKPictureInPicureController where Self : UIKit.UIViewController {
  public var isPictureInPictureActive: Swift.Bool {
    get
  }
  public var pictureInPictureSize: CoreGraphics.CGSize {
    get
    set
  }
  public var pictureInPicturePosition: FlipFlopSDK.HKPictureInPicureControllerPosition {
    get
    set
  }
  public var pictureInPictureMargin: CoreGraphics.CGFloat {
    get
    set
  }
  public var pictureInPictureCornerRadius: CoreGraphics.CGFloat {
    get
    set
  }
  public var pictureInPictureAnimationDuration: Foundation.TimeInterval {
    get
    set
  }
  public func startPictureInPicture()
  public func stopPictureInPicture()
}
public struct Empty : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
extension UIDevice {
  public var type: Swift.String {
    get
  }
}
@objc public protocol FFConferenceDelegate {
  @objc func onJoined(conference: FlipFlopSDK.FFConference, room: Swift.String, userID: Swift.String) -> UIKit.UIView?
  @objc func onLeaved(conference: FlipFlopSDK.FFConference, room: Swift.String, userID: Swift.String)
}
@_hasMissingDesignatedInitializers @objc public class FFConference : ObjectiveC.NSObject {
  @objc weak public var delegate: FlipFlopSDK.FFConferenceDelegate?
  @objc deinit
  @objc public func prepare(preview: UIKit.UIView)
  @objc public func join()
  @objc public func leave()
  @objc override dynamic public init()
}
extension FFConference : FlipFlopSDK.WebRTCConferenceDelegate {
  public func onJoined(conference: FlipFlopSDK.WebRTCConference, room: Swift.String, userID: Swift.String) -> UIKit.UIView?
  public func onLeaved(conference: FlipFlopSDK.WebRTCConference, room: Swift.String, userID: Swift.String)
}
@_hasMissingDesignatedInitializers public class MP4Sampler {
  public typealias Handler = () -> Swift.Void
  public var isRunning: FlipFlopSDK.Atomic<Swift.Bool> {
    get
  }
  @objc deinit
}
extension MP4Sampler : FlipFlopSDK.Running {
  public func startRunning()
  public func stopRunning()
}
public class AVMixer {
  public static let bufferEmpty: Foundation.Notification.Name
  public static let defaultFPS: Swift.Double
  public static let defaultVideoSettings: [Foundation.NSString : Swift.AnyObject]
  public enum Option : Swift.String, FlipFlopSDK.KeyPathRepresentable, Swift.CaseIterable {
    case fps
    case sessionPreset
    case isVideoMirrored
    case continuousAutofocus
    case continuousExposure
    case preferredVideoStabilizationMode
    public var keyPath: Swift.AnyKeyPath {
      get
    }
    public init?(rawValue: Swift.String)
    public typealias AllCases = [FlipFlopSDK.AVMixer.Option]
    public typealias RawValue = Swift.String
    public static var allCases: [FlipFlopSDK.AVMixer.Option] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  public var session: AVFoundation.AVCaptureSession {
    get
    set
  }
  public var recorder: FlipFlopSDK.AVRecorder! {
    get
  }
  @objc deinit
  public init()
  public func dispose()
}
extension AVMixer {
  public func startEncoding(delegate: Any)
  public func stopEncoding()
}
extension AVMixer : FlipFlopSDK.Running {
  public var isRunning: FlipFlopSDK.Atomic<Swift.Bool> {
    get
  }
  public func startRunning()
  public func stopRunning()
}
@objc open class NetService : ObjectiveC.NSObject {
  open var txtData: Foundation.Data? {
    get
  }
  public var domain: Swift.String {
    get
  }
  public var name: Swift.String {
    get
  }
  public var port: Swift.Int32 {
    get
  }
  public var type: Swift.String {
    get
  }
  public var isRunning: FlipFlopSDK.Atomic<Swift.Bool> {
    get
  }
  public var clients: [FlipFlopSDK.NetClient] {
    get
  }
  public init(domain: Swift.String, type: Swift.String, name: Swift.String, port: Swift.Int32)
  @objc override dynamic public init()
  @objc deinit
}
extension NetService : Foundation.NetServiceDelegate {
  @objc dynamic public func netService(_ sender: Foundation.NetService, didAcceptConnectionWith inputStream: Foundation.InputStream, outputStream: Foundation.OutputStream)
}
extension NetService : FlipFlopSDK.Running {
  public func startRunning()
  public func stopRunning()
}
public class StringHTTPHandler : FlipFlopSDK.HTTPHandler {
  public init()
  public func convert(request: Foundation.URLRequest) -> Foundation.Data
  public func parse(data: Foundation.Data) -> Swift.Int
  public func register(delegate: FlipFlopSDK.HTTPHandlerDelegate)
  @objc deinit
}
@_hasMissingDesignatedInitializers open class ByteArray {
  public enum Error : Swift.Error {
    case eof
    case parse
    public static func == (a: FlipFlopSDK.ByteArray.Error, b: FlipFlopSDK.ByteArray.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  open var length: Swift.Int {
    get
    set
  }
  open var position: Swift.Int
  open var bytesAvailable: Swift.Int {
    get
  }
  open subscript(i: Swift.Int) -> Swift.UInt8 {
    get
    set
  }
  open func readUInt8() throws -> Swift.UInt8
  @discardableResult
  open func writeUInt8(_ value: Swift.UInt8) -> Self
  open func readInt8() throws -> Swift.Int8
  @discardableResult
  open func writeInt8(_ value: Swift.Int8) -> Self
  open func readUInt16() throws -> Swift.UInt16
  @discardableResult
  open func writeUInt16(_ value: Swift.UInt16) -> Self
  open func readInt16() throws -> Swift.Int16
  @discardableResult
  open func writeInt16(_ value: Swift.Int16) -> Self
  open func readUInt24() throws -> Swift.UInt32
  @discardableResult
  open func writeUInt24(_ value: Swift.UInt32) -> Self
  open func readUInt32() throws -> Swift.UInt32
  @discardableResult
  open func writeUInt32(_ value: Swift.UInt32) -> Self
  open func readInt32() throws -> Swift.Int32
  @discardableResult
  open func writeInt32(_ value: Swift.Int32) -> Self
  open func readDouble() throws -> Swift.Double
  @discardableResult
  open func writeDouble(_ value: Swift.Double) -> Self
  open func readFloat() throws -> Swift.Float
  @discardableResult
  open func writeFloat(_ value: Swift.Float) -> Self
  open func readUTF8() throws -> Swift.String
  @discardableResult
  open func writeUTF8(_ value: Swift.String) throws -> Self
  open func readUTF8Bytes(_ length: Swift.Int) throws -> Swift.String
  @discardableResult
  open func writeUTF8Bytes(_ value: Swift.String) -> Self
  open func readBytes(_ length: Swift.Int) throws -> Foundation.Data
  @discardableResult
  open func writeBytes(_ value: Foundation.Data) -> Self
  @discardableResult
  open func clear() -> Self
  @objc deinit
}
extension ByteArray : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public protocol HKPictureInPicureController : AnyObject {
  var isPictureInPictureActive: Swift.Bool { get }
  var pictureInPictureSize: CoreGraphics.CGSize { get set }
  var pictureInPicturePosition: FlipFlopSDK.HKPictureInPicureControllerPosition { get set }
  var pictureInPictureMargin: CoreGraphics.CGFloat { get set }
  var pictureInPictureCornerRadius: CoreGraphics.CGFloat { get set }
  var pictureInPictureAnimationDuration: Foundation.TimeInterval { get set }
  func startPictureInPicture()
  func stopPictureInPicture()
}
extension CMSampleBuffer {
}
public enum FLVAudioCodec : Swift.UInt8 {
  case pcm
  case adpcm
  case mp3
  case pcmle
  case nellymoser16K
  case nellymoser8K
  case nellymoser
  case g711A
  case g711MU
  case aac
  case speex
  case mp3_8k
  case unknown
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public protocol WebRTCConferenceDelegate : AnyObject {
  func onJoined(conference: FlipFlopSDK.WebRTCConference, room: Swift.String, userID: Swift.String) -> UIKit.UIView?
  func onLeaved(conference: FlipFlopSDK.WebRTCConference, room: Swift.String, userID: Swift.String)
}
@objc @_hasMissingDesignatedInitializers open class WebRTCConference : ObjectiveC.NSObject {
  open func preprare(preview: UIKit.UIView)
  open func join(url: Swift.String)
  open func leave()
  @objc deinit
  @objc override dynamic public init()
}
@objc @_inheritsConvenienceInitializers open class VideoEffect : ObjectiveC.NSObject {
  open var ciContext: CoreImage.CIContext? {
    get
  }
  open func execute(_ image: CoreImage.CIImage) -> CoreImage.CIImage
  @objc override dynamic public init()
  @objc deinit
}
public protocol TimerDriverDelegate : AnyObject {
  func tick(_ driver: FlipFlopSDK.TimerDriver)
}
@_hasMissingDesignatedInitializers public class TimerDriver {
  public var interval: Swift.UInt64
  public func setDelegate(_ delegate: FlipFlopSDK.TimerDriverDelegate, withQueue: Dispatch.DispatchQueue? = nil)
  @objc deinit
}
extension TimerDriver : FlipFlopSDK.Running {
  public var isRunning: FlipFlopSDK.Atomic<Swift.Bool> {
    get
  }
  public func startRunning()
  public func stopRunning()
}
public class WSEngine : FlipFlopSDK.Engine, FlipFlopSDK.TransportEventClient, FlipFlopSDK.FramerEventClient, FlipFlopSDK.FrameCollectorDelegate, FlipFlopSDK.HTTPHandlerDelegate {
  public var respondToPingWithPong: Swift.Bool
  public init(transport: FlipFlopSDK.Transport, certPinner: FlipFlopSDK.CertificatePinning? = nil, headerValidator: FlipFlopSDK.HeaderValidator = FoundationSecurity(), httpHandler: FlipFlopSDK.HTTPHandler = FoundationHTTPHandler(), framer: FlipFlopSDK.Framer = WSFramer(), compressionHandler: FlipFlopSDK.CompressionHandler? = nil)
  public func register(delegate: FlipFlopSDK.EngineDelegate)
  public func start(request: Foundation.URLRequest)
  public func stop(closeCode: Swift.UInt16 = CloseCode.normal.rawValue)
  public func forceStop()
  public func write(string: Swift.String, completion: (() -> ())?)
  public func write(data: Foundation.Data, opcode: FlipFlopSDK.FrameOpCode, completion: (() -> ())?)
  public func connectionChanged(state: FlipFlopSDK.ConnectionState)
  public func didReceiveHTTP(event: FlipFlopSDK.HTTPEvent)
  public func frameProcessed(event: FlipFlopSDK.FrameEvent)
  public func decompress(data: Foundation.Data, isFinal: Swift.Bool) -> Foundation.Data?
  public func didForm(event: FlipFlopSDK.FrameCollector.Event)
  @objc deinit
}
public protocol CompressionHandler {
  func load(headers: [Swift.String : Swift.String])
  func decompress(data: Foundation.Data, isFinal: Swift.Bool) -> Foundation.Data?
  func compress(data: Foundation.Data) -> Foundation.Data?
}
extension NetStream {
  open var orientation: AVFoundation.AVCaptureVideoOrientation {
    get
    set
  }
  open func attachScreen(_ screen: FlipFlopSDK.CustomCaptureSession?, useScreenSize: Swift.Bool = true)
  open var zoomFactor: CoreGraphics.CGFloat {
    get
  }
  open func setZoomFactor(_ zoomFactor: CoreGraphics.CGFloat, ramping: Swift.Bool = false, withRate: Swift.Float = 2.0)
}
@objc @_inheritsConvenienceInitializers open class AudioEffect : ObjectiveC.NSObject {
  open func execute(_ buffer: CoreAudio.UnsafeMutableAudioBufferListPointer?, format: CoreAudioTypes.AudioStreamBasicDescription?)
  @objc override dynamic public init()
  @objc deinit
}
public typealias HttpCompletion = ((Swift.Int, Foundation.Data?, Swift.Error?) -> Swift.Void)?
public enum FLVSoundSize : Swift.UInt8 {
  case snd8bit
  case snd16bit
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
@objc open class GLHKView : GLKit.GLKView {
  public static var defaultBackgroundColor: UIKit.UIColor
  open var isMirrored: Swift.Bool
  open var videoGravity: AVFoundation.AVLayerVideoGravity
  open var videoFormatDescription: CoreMedia.CMVideoFormatDescription? {
    get
  }
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc override dynamic open func awakeFromNib()
  open func attachStream(_ stream: FlipFlopSDK.NetStream?)
  @objc override dynamic public init(frame: CoreGraphics.CGRect, context: OpenGLES.EAGLContext)
  @objc deinit
}
extension GLHKView : GLKit.GLKViewDelegate {
  @objc dynamic public func glkView(_ view: GLKit.GLKView, drawIn rect: CoreGraphics.CGRect)
}
public enum FLVSoundType : Swift.UInt8 {
  case mono
  case stereo
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public enum ConnectionEvent {
  case connected([Swift.String : Swift.String])
  case disconnected(Swift.String, Swift.UInt16)
  case text(Swift.String)
  case binary(Foundation.Data)
  case pong(Foundation.Data?)
  case ping(Foundation.Data?)
  case error(Swift.Error)
}
public protocol Connection {
  func write(data: Foundation.Data, opcode: FlipFlopSDK.FrameOpCode)
}
public protocol ConnectionDelegate : AnyObject {
  func didReceive(event: FlipFlopSDK.ServerEvent)
}
public enum ServerEvent {
  case connected(FlipFlopSDK.Connection, [Swift.String : Swift.String])
  case disconnected(FlipFlopSDK.Connection, Swift.String, Swift.UInt16)
  case text(FlipFlopSDK.Connection, Swift.String)
  case binary(FlipFlopSDK.Connection, Foundation.Data)
  case pong(FlipFlopSDK.Connection, Foundation.Data?)
  case ping(FlipFlopSDK.Connection, Foundation.Data?)
}
public protocol Server {
  func start(address: Swift.String, port: Swift.UInt16) -> Swift.Error?
}
public enum TCPTransportError : Swift.Error {
  case invalidRequest
  public static func == (a: FlipFlopSDK.TCPTransportError, b: FlipFlopSDK.TCPTransportError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
public class TCPTransport : FlipFlopSDK.Transport {
  public var usingTLS: Swift.Bool {
    get
  }
  public init(connection: Network.NWConnection)
  public init()
  public func connect(url: Foundation.URL, timeout: Swift.Double = 10, certificatePinning: FlipFlopSDK.CertificatePinning? = nil)
  public func disconnect()
  public func register(delegate: FlipFlopSDK.TransportEventClient)
  public func write(data: Foundation.Data, completion: @escaping ((Swift.Error?) -> ()))
  @objc deinit
}
extension AudioCodec {
  public enum Destination {
    case aac
    case pcm
    public static func == (a: FlipFlopSDK.AudioCodec.Destination, b: FlipFlopSDK.AudioCodec.Destination) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@objc public enum Preset : Swift.Int {
  case hd1920x1080
  case hd1280x720
  case vga640x480
  case cif352x288
  public var value: AVFoundation.AVCaptureSession.Preset {
    get
  }
  public var resolution: (width: Swift.Int, height: Swift.Int) {
    get
  }
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum FLVSoundRate : Swift.UInt8 {
  case kHz5_5
  case kHz11
  case kHz22
  case kHz44
  public var floatValue: Swift.Float64 {
    get
  }
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public enum FoundationSecurityError : Swift.Error {
  case invalidRequest
  public static func == (a: FlipFlopSDK.FoundationSecurityError, b: FlipFlopSDK.FoundationSecurityError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class FoundationSecurity {
  public init(allowSelfSigned: Swift.Bool = false)
  @objc deinit
}
extension FoundationSecurity : FlipFlopSDK.CertificatePinning {
  public func evaluateTrust(trust: Security.SecTrust, domain: Swift.String?, completion: ((FlipFlopSDK.PinningState) -> ()))
}
extension FoundationSecurity : FlipFlopSDK.HeaderValidator {
  public func validate(headers: [Swift.String : Swift.String], key: Swift.String) -> Swift.Error?
}
public protocol EngineDelegate : AnyObject {
  func didReceive(event: FlipFlopSDK.WebSocketEvent)
}
public protocol Engine {
  func register(delegate: FlipFlopSDK.EngineDelegate)
  func start(request: Foundation.URLRequest)
  func stop(closeCode: Swift.UInt16)
  func forceStop()
  func write(data: Foundation.Data, opcode: FlipFlopSDK.FrameOpCode, completion: (() -> ())?)
  func write(string: Swift.String, completion: (() -> ())?)
}
@objc open class RTMPStream : FlipFlopSDK.NetStream {
  public enum Code : Swift.String {
    case bufferEmpty
    case bufferFlush
    case bufferFull
    case connectClosed
    case connectFailed
    case connectRejected
    case connectSuccess
    case drmUpdateNeeded
    case failed
    case multicastStreamReset
    case pauseNotify
    case playFailed
    case playFileStructureInvalid
    case playInsufficientBW
    case playNoSupportedTrackFound
    case playReset
    case playStart
    case playStop
    case playStreamNotFound
    case playTransition
    case playUnpublishNotify
    case publishBadName
    case publishIdle
    case publishStart
    case recordAlreadyExists
    case recordFailed
    case recordNoAccess
    case recordStart
    case recordStop
    case recordDiskQuotaExceeded
    case secondScreenStart
    case secondScreenStop
    case seekFailed
    case seekInvalidTime
    case seekNotify
    case stepNotify
    case unpauseNotify
    case unpublishSuccess
    case videoDimensionChange
    public var level: Swift.String {
      get
    }
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum PlayTransition : Swift.String {
    case append
    case appendAndWait
    case reset
    case resume
    case stop
    case swap
    case `switch`
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public struct PlayOption : Swift.CustomDebugStringConvertible {
    public var len: Swift.Double
    public var offset: Swift.Double
    public var oldStreamName: Swift.String
    public var start: Swift.Double
    public var streamName: Swift.String
    public var transition: FlipFlopSDK.RTMPStream.PlayTransition
    public var debugDescription: Swift.String {
      get
    }
  }
  public enum HowToPublish : Swift.String {
    case record
    case append
    case appendWithGap
    case live
    case localRecord
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public static let defaultAudioBitrate: Swift.UInt32
  public static let defaultVideoBitrate: Swift.UInt32
  open var info: FlipFlopSDK.RTMPStreamInfo {
    get
  }
  open var objectEncoding: FlipFlopSDK.RTMPObjectEncoding {
    get
  }
  @objc dynamic open var currentFPS: Swift.UInt16 {
    get
  }
  open var soundTransform: FlipFlopSDK.SoundTransform {
    get
    set
  }
  open var receiveAudio: Swift.Bool {
    get
    set
  }
  open var receiveVideo: Swift.Bool {
    get
    set
  }
  open var paused: Swift.Bool {
    get
    set
  }
  public init(connection: FlipFlopSDK.RTMPConnection)
  @objc deinit
  open func play(_ arguments: Any?...)
  open func seek(_ offset: Swift.Double)
  open func publish(_ name: Swift.String?, type: FlipFlopSDK.RTMPStream.HowToPublish = .live)
  open func close()
  open func send(handlerName: Swift.String, arguments: Any?...)
  open func appendFile(_ file: Foundation.URL, completionHandler: FlipFlopSDK.MP4Sampler.Handler? = nil)
  open func createMetaData() -> FlipFlopSDK.ASObject
  @objc override dynamic public init()
}
public struct RTMPStreamInfo {
  public var byteCount: FlipFlopSDK.Atomic<Swift.Int64> {
    get
  }
  public var resourceName: Swift.String? {
    get
  }
  public var currentBytesPerSecond: Swift.Int32 {
    get
  }
}
extension RTMPStreamInfo : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public enum ErrorType : Swift.Error {
  case compressionError
  case securityError
  case protocolError
  case serverError
  public static func == (a: FlipFlopSDK.ErrorType, b: FlipFlopSDK.ErrorType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct WSError : Swift.Error {
  public let type: FlipFlopSDK.ErrorType
  public let message: Swift.String
  public let code: Swift.UInt16
  public init(type: FlipFlopSDK.ErrorType, message: Swift.String, code: Swift.UInt16)
}
public protocol WebSocketClient : AnyObject {
  func connect()
  func disconnect(closeCode: Swift.UInt16)
  func write(string: Swift.String, completion: (() -> ())?)
  func write(stringData: Foundation.Data, completion: (() -> ())?)
  func write(data: Foundation.Data, completion: (() -> ())?)
  func write(ping: Foundation.Data, completion: (() -> ())?)
  func write(pong: Foundation.Data, completion: (() -> ())?)
}
extension WebSocketClient {
  public func write(string: Swift.String)
  public func write(data: Foundation.Data)
  public func write(ping: Foundation.Data)
  public func write(pong: Foundation.Data)
  public func disconnect()
}
public enum WebSocketEvent {
  case connected([Swift.String : Swift.String])
  case disconnected(Swift.String, Swift.UInt16)
  case text(Swift.String)
  case binary(Foundation.Data)
  case pong(Foundation.Data?)
  case ping(Foundation.Data?)
  case error(Swift.Error?)
  case viabilityChanged(Swift.Bool)
  case reconnectSuggested(Swift.Bool)
  case cancelled
}
public protocol WebSocketDelegate : AnyObject {
  func didReceive(event: FlipFlopSDK.WebSocketEvent, client: FlipFlopSDK.WebSocket)
}
open class WebSocket : FlipFlopSDK.WebSocketClient, FlipFlopSDK.EngineDelegate {
  weak public var delegate: FlipFlopSDK.WebSocketDelegate?
  public var onEvent: ((FlipFlopSDK.WebSocketEvent) -> Swift.Void)?
  public var request: Foundation.URLRequest
  public var callbackQueue: Dispatch.DispatchQueue
  public var respondToPingWithPong: Swift.Bool {
    get
    set
  }
  public init(request: Foundation.URLRequest, engine: FlipFlopSDK.Engine)
  convenience public init(request: Foundation.URLRequest, certPinner: FlipFlopSDK.CertificatePinning? = FoundationSecurity(), compressionHandler: FlipFlopSDK.CompressionHandler? = nil, useCustomEngine: Swift.Bool = true)
  public func connect()
  public func disconnect(closeCode: Swift.UInt16 = CloseCode.normal.rawValue)
  public func forceDisconnect()
  public func write(data: Foundation.Data, completion: (() -> ())?)
  public func write(string: Swift.String, completion: (() -> ())?)
  public func write(stringData: Foundation.Data, completion: (() -> ())?)
  public func write(ping: Foundation.Data, completion: (() -> ())?)
  public func write(pong: Foundation.Data, completion: (() -> ())?)
  public func didReceive(event: FlipFlopSDK.WebSocketEvent)
  @objc deinit
}
public enum EventPhase : Swift.UInt8 {
  case capturing
  case atTarget
  case bubbling
  case dispose
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
open class Event {
  public struct Name : Swift.RawRepresentable, Swift.ExpressibleByStringLiteral {
    public typealias RawValue = Swift.String
    public typealias StringLiteralType = Swift.String
    public static let sync: FlipFlopSDK.Event.Name
    public static let event: FlipFlopSDK.Event.Name
    public static let ioError: FlipFlopSDK.Event.Name
    public static let rtmpStatus: FlipFlopSDK.Event.Name
    public let rawValue: Swift.String
    public init(rawValue: Swift.String)
    public init(stringLiteral value: Swift.String)
    public typealias ExtendedGraphemeClusterLiteralType = FlipFlopSDK.Event.Name.StringLiteralType
    public typealias UnicodeScalarLiteralType = FlipFlopSDK.Event.Name.StringLiteralType
  }
  public static func from(_ notification: Foundation.Notification) -> FlipFlopSDK.Event
  open var type: FlipFlopSDK.Event.Name {
    get
  }
  open var bubbles: Swift.Bool {
    get
  }
  open var data: Any? {
    get
  }
  open var target: Swift.AnyObject? {
    get
  }
  public init(type: FlipFlopSDK.Event.Name, bubbles: Swift.Bool = false, data: Any? = nil)
  @objc deinit
}
extension Event : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
open class EventDispatcher {
  public init()
  public init(target: Swift.AnyObject)
  @objc deinit
  public func addEventListener(_ type: FlipFlopSDK.Event.Name, selector: ObjectiveC.Selector, observer: Swift.AnyObject? = nil, useCapture: Swift.Bool = false)
  public func removeEventListener(_ type: FlipFlopSDK.Event.Name, selector: ObjectiveC.Selector, observer: Swift.AnyObject? = nil, useCapture: Swift.Bool = false)
  open func dispatch(event: FlipFlopSDK.Event)
  public func dispatch(_ type: FlipFlopSDK.Event.Name, bubbles: Swift.Bool, data: Any?)
}
public protocol AudioCodecDelegate : AnyObject {
  func didSetFormatDescription(audio formatDescription: CoreMedia.CMFormatDescription?)
  func sampleOutput(audio data: CoreAudio.UnsafeMutableAudioBufferListPointer, presentationTimeStamp: CoreMedia.CMTime)
}
public class AudioCodec {
  public enum Option : Swift.String, FlipFlopSDK.KeyPathRepresentable {
    case muted
    case bitrate
    case sampleRate
    case actualBitrate
    public var keyPath: Swift.AnyKeyPath {
      get
    }
    public init?(rawValue: Swift.String)
    public typealias AllCases = [FlipFlopSDK.AudioCodec.Option]
    public typealias RawValue = Swift.String
    public static var allCases: [FlipFlopSDK.AudioCodec.Option] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  public static let minimumBitrate: Swift.UInt32
  public static let defaultBitrate: Swift.UInt32
  public static let defaultChannels: Swift.UInt32
  public static let defaultSampleRate: Swift.Double
  public static let defaultMaximumBuffers: Swift.Int
  public var destination: FlipFlopSDK.AudioCodec.Destination
  weak public var delegate: FlipFlopSDK.AudioCodecDelegate?
  public var isRunning: FlipFlopSDK.Atomic<Swift.Bool> {
    get
  }
  public var settings: FlipFlopSDK.Setting<FlipFlopSDK.AudioCodec, FlipFlopSDK.AudioCodec.Option> {
    get
    set
  }
  public init()
  public func encodeBytes(_ bytes: Swift.UnsafeMutableRawPointer?, count: Swift.Int, presentationTimeStamp: CoreMedia.CMTime)
  public func encodeSampleBuffer(_ sampleBuffer: CoreMedia.CMSampleBuffer, offset: Swift.Int = 0)
  @objc deinit
}
extension AudioCodec : FlipFlopSDK.Running {
  public func startRunning()
  public func stopRunning()
}
open class FLVReader {
  public static let header: Foundation.Data
  final public let url: Foundation.URL
  public init(url: Foundation.URL)
  public func getData(_ tag: FlipFlopSDK.FLVTag) -> Foundation.Data?
  @objc deinit
}
extension FLVReader : Swift.IteratorProtocol {
  public func next() -> FlipFlopSDK.FLVTag?
  public typealias Element = FlipFlopSDK.FLVTag
}
@_hasMissingDesignatedInitializers public class FoundationHTTPServerHandler : FlipFlopSDK.HTTPServerHandler {
  public func register(delegate: FlipFlopSDK.HTTPServerDelegate)
  public func createResponse(headers: [Swift.String : Swift.String]) -> Foundation.Data
  public func parse(data: Foundation.Data)
  @objc deinit
}
public enum StompAckMode {
  case AutoMode
  case ClientMode
  case ClientIndividualMode
  public static func == (a: FlipFlopSDK.StompAckMode, b: FlipFlopSDK.StompAckMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@objc public protocol StompClientLibDelegate {
  @objc func stompClient(client: FlipFlopSDK.StompClientLib!, didReceiveMessageWithJSONBody jsonBody: Swift.AnyObject?, akaStringBody stringBody: Swift.String?, withHeader header: [Swift.String : Swift.String]?, withDestination destination: Swift.String)
  @objc func stompClientDidDisconnect(client: FlipFlopSDK.StompClientLib!)
  @objc func stompClientDidConnect(client: FlipFlopSDK.StompClientLib!)
  @objc func serverDidSendReceipt(client: FlipFlopSDK.StompClientLib!, withReceiptId receiptId: Swift.String)
  @objc func serverDidSendError(client: FlipFlopSDK.StompClientLib!, withErrorMessage description: Swift.String, detailedErrorMessage message: Swift.String?)
  @objc func serverDidSendPing()
}
@objc @_inheritsConvenienceInitializers @objcMembers public class StompClientLib : ObjectiveC.NSObject, SocketRocket.SRWebSocketDelegate {
  @objc public var connection: Swift.Bool
  @objc public var certificateCheckEnabled: Swift.Bool
  @objc public static var defaultHeartBitTime: Swift.Double
  @objc public func sendPing()
  @objc public func sendJSONForDict(dict: Swift.AnyObject, toDestination destination: Swift.String)
  @objc public func openSocketWithURLRequest(request: Foundation.NSURLRequest, delegate: FlipFlopSDK.StompClientLibDelegate, connectionHeaders: [Swift.String : Swift.String]? = nil)
  @objc public func webSocket(_ webSocket: SocketRocket.SRWebSocket!, didReceiveMessage message: Any!)
  @objc public func webSocketDidOpen(_ webSocket: SocketRocket.SRWebSocket!)
  @objc public func webSocket(_ webSocket: SocketRocket.SRWebSocket!, didFailWithError error: Swift.Error!)
  @objc public func webSocket(_ webSocket: SocketRocket.SRWebSocket!, didCloseWithCode code: Swift.Int, reason: Swift.String!, wasClean: Swift.Bool)
  @objc public func webSocket(_ webSocket: SocketRocket.SRWebSocket!, didReceivePong pongPayload: Foundation.Data!)
  @objc public func sendMessage(message: Swift.String, toDestination destination: Swift.String, withHeaders headers: [Swift.String : Swift.String]?, withReceipt receipt: Swift.String?)
  @objc public func isConnected() -> Swift.Bool
  @objc public func subscribe(destination: Swift.String)
  public func subscribeToDestination(destination: Swift.String, ackMode: FlipFlopSDK.StompAckMode)
  @objc public func subscribeWithHeader(destination: Swift.String, withHeader header: [Swift.String : Swift.String])
  @objc public func unsubscribe(destination: Swift.String)
  @objc public func begin(transactionId: Swift.String)
  @objc public func commit(transactionId: Swift.String)
  @objc public func abort(transactionId: Swift.String)
  @objc public func ack(messageId: Swift.String)
  @objc public func ack(messageId: Swift.String, withSubscription subscription: Swift.String)
  @objc public func disconnect()
  @objc public func reconnect(request: Foundation.NSURLRequest, delegate: FlipFlopSDK.StompClientLibDelegate, connectionHeaders: [Swift.String : Swift.String] = [String: String](), time: Swift.Double = 1.0, exponentialBackoff: Swift.Bool = true)
  @objc public func stopReconnect()
  @objc public func autoDisconnect(time: Swift.Double)
  @objc override dynamic public init()
  @objc deinit
}
public enum FLVAACPacketType : Swift.UInt8 {
  case seq
  case raw
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public enum Device {
  case iPodTouch5
  case iPodTouch6
  case iPodTouch7
  case iPhone4
  case iPhone4s
  case iPhone5
  case iPhone5c
  case iPhone5s
  case iPhone6
  case iPhone6Plus
  case iPhone6s
  case iPhone6sPlus
  case iPhone7
  case iPhone7Plus
  case iPhoneSE
  case iPhone8
  case iPhone8Plus
  case iPhoneX
  case iPhoneXS
  case iPhoneXSMax
  case iPhoneXR
  case iPhone11
  case iPhone11Pro
  case iPhone11ProMax
  case iPhoneSE2
  case iPhone12
  case iPhone12Mini
  case iPhone12Pro
  case iPhone12ProMax
  case iPad2
  case iPad3
  case iPad4
  case iPadAir
  case iPadAir2
  case iPad5
  case iPad6
  case iPadAir3
  case iPad7
  case iPad8
  case iPadAir4
  case iPadMini
  case iPadMini2
  case iPadMini3
  case iPadMini4
  case iPadMini5
  case iPadPro9Inch
  case iPadPro12Inch
  case iPadPro12Inch2
  case iPadPro10Inch
  case iPadPro11Inch
  case iPadPro12Inch3
  case iPadPro11Inch2
  case iPadPro12Inch4
  case iPadPro11Inch3
  case iPadPro12Inch5
  case homePod
  indirect case simulator(FlipFlopSDK.Device)
  case unknown(Swift.String)
  public static var current: FlipFlopSDK.Device {
    get
  }
  public static var identifier: Swift.String
  public static func mapToDevice(identifier: Swift.String) -> FlipFlopSDK.Device
  public static func realDevice(from device: FlipFlopSDK.Device) -> FlipFlopSDK.Device
  public var diagonal: Swift.Double {
    get
  }
  public var screenRatio: (width: Swift.Double, height: Swift.Double) {
    get
  }
  public static var allPods: [FlipFlopSDK.Device] {
    get
  }
  public static var allPhones: [FlipFlopSDK.Device] {
    get
  }
  public static var allPads: [FlipFlopSDK.Device] {
    get
  }
  @available(*, deprecated, renamed: "allDevicesWithSensorHousing")
  public static var allXSeriesDevices: [FlipFlopSDK.Device] {
    get
  }
  public static var allPlusSizedDevices: [FlipFlopSDK.Device] {
    get
  }
  public static var allProDevices: [FlipFlopSDK.Device] {
    get
  }
  public static var allMiniDevices: [FlipFlopSDK.Device] {
    get
  }
  public static var allSimulatorPods: [FlipFlopSDK.Device] {
    get
  }
  public static var allSimulatorPhones: [FlipFlopSDK.Device] {
    get
  }
  public static var allSimulatorPads: [FlipFlopSDK.Device] {
    get
  }
  public static var allSimulatorMiniDevices: [FlipFlopSDK.Device] {
    get
  }
  @available(*, deprecated, renamed: "allSimulatorDevicesWithSensorHousing")
  public static var allSimulatorXSeriesDevices: [FlipFlopSDK.Device] {
    get
  }
  public static var allSimulatorPlusSizedDevices: [FlipFlopSDK.Device] {
    get
  }
  public static var allSimulatorProDevices: [FlipFlopSDK.Device] {
    get
  }
  public var isPod: Swift.Bool {
    get
  }
  public var isPhone: Swift.Bool {
    get
  }
  public var isPad: Swift.Bool {
    get
  }
  public var isSimulator: Swift.Bool {
    get
  }
  public var realDevice: FlipFlopSDK.Device {
    get
  }
  public var isZoomed: Swift.Bool? {
    get
  }
  public static var allTouchIDCapableDevices: [FlipFlopSDK.Device] {
    get
  }
  public static var allFaceIDCapableDevices: [FlipFlopSDK.Device] {
    get
  }
  public static var allBiometricAuthenticationCapableDevices: [FlipFlopSDK.Device] {
    get
  }
  public var isTouchIDCapable: Swift.Bool {
    get
  }
  public var isFaceIDCapable: Swift.Bool {
    get
  }
  public var hasBiometricSensor: Swift.Bool {
    get
  }
  public static var allDevicesWithSensorHousing: [FlipFlopSDK.Device] {
    get
  }
  public static var allSimulatorDevicesWithSensorHousing: [FlipFlopSDK.Device] {
    get
  }
  public var hasSensorHousing: Swift.Bool {
    get
  }
  public static var allDevicesWithRoundedDisplayCorners: [FlipFlopSDK.Device] {
    get
  }
  public var hasRoundedDisplayCorners: Swift.Bool {
    get
  }
  public static var allDevicesWith3dTouchSupport: [FlipFlopSDK.Device] {
    get
  }
  public var has3dTouchSupport: Swift.Bool {
    get
  }
  public static var allDevicesWithWirelessChargingSupport: [FlipFlopSDK.Device] {
    get
  }
  public var supportsWirelessCharging: Swift.Bool {
    get
  }
  public static var allDevicesWithALidarSensor: [FlipFlopSDK.Device] {
    get
  }
  public var hasLidarSensor: Swift.Bool {
    get
  }
  public static var allRealDevices: [FlipFlopSDK.Device] {
    get
  }
  public static var allSimulators: [FlipFlopSDK.Device] {
    get
  }
  public func isOneOf(_ devices: [FlipFlopSDK.Device]) -> Swift.Bool
  public var name: Swift.String? {
    get
  }
  public var systemName: Swift.String? {
    get
  }
  public var systemVersion: Swift.String? {
    get
  }
  public var model: Swift.String? {
    get
  }
  public var localizedModel: Swift.String? {
    get
  }
  public var ppi: Swift.Int? {
    get
  }
  public var isGuidedAccessSessionActive: Swift.Bool {
    get
  }
  public var screenBrightness: Swift.Int {
    get
  }
}
extension Device : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
  public var safeDescription: Swift.String {
    get
  }
}
extension Device : Swift.Equatable {
  public static func == (lhs: FlipFlopSDK.Device, rhs: FlipFlopSDK.Device) -> Swift.Bool
}
@available(iOS 8.0, watchOS 4.0, *)
extension Device {
  public enum BatteryState : Swift.CustomStringConvertible, Swift.Equatable {
    case full
    case charging(Swift.Int)
    case unplugged(Swift.Int)
    public var lowPowerMode: Swift.Bool {
      get
    }
    public var description: Swift.String {
      get
    }
  }
  public var batteryState: FlipFlopSDK.Device.BatteryState? {
    get
  }
  public var batteryLevel: Swift.Int? {
    get
  }
}
@available(iOS 8.0, watchOS 4.0, *)
extension Device.BatteryState : Swift.Comparable {
  public static func == (lhs: FlipFlopSDK.Device.BatteryState, rhs: FlipFlopSDK.Device.BatteryState) -> Swift.Bool
  public static func < (lhs: FlipFlopSDK.Device.BatteryState, rhs: FlipFlopSDK.Device.BatteryState) -> Swift.Bool
}
extension Device {
  public enum Orientation {
    case landscape
    case portrait
    public static func == (a: FlipFlopSDK.Device.Orientation, b: FlipFlopSDK.Device.Orientation) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var orientation: FlipFlopSDK.Device.Orientation {
    get
  }
}
extension Device {
  public static var volumeTotalCapacity: Swift.Int? {
    get
  }
  public static var volumeAvailableCapacity: Swift.Int? {
    get
  }
  @available(iOS 11.0, *)
  public static var volumeAvailableCapacityForImportantUsage: Swift.Int64? {
    get
  }
  @available(iOS 11.0, *)
  public static var volumeAvailableCapacityForOpportunisticUsage: Swift.Int64? {
    get
  }
  @available(iOS 11.0, *)
  public static var volumes: [Foundation.URLResourceKey : Swift.Int64]? {
    get
  }
}
extension Device {
  public struct ApplePencilSupport : Swift.OptionSet {
    public var rawValue: Swift.UInt
    public init(rawValue: Swift.UInt)
    public static let firstGeneration: FlipFlopSDK.Device.ApplePencilSupport
    public static let secondGeneration: FlipFlopSDK.Device.ApplePencilSupport
    public typealias ArrayLiteralElement = FlipFlopSDK.Device.ApplePencilSupport
    public typealias Element = FlipFlopSDK.Device.ApplePencilSupport
    public typealias RawValue = Swift.UInt
  }
  public static var allApplePencilCapableDevices: [FlipFlopSDK.Device] {
    get
  }
  public var applePencilSupport: FlipFlopSDK.Device.ApplePencilSupport {
    get
  }
}
extension Device {
  public enum CameraType {
    @available(*, deprecated, renamed: "wide")
    case normal
    case wide
    case telephoto
    case ultraWide
    public static func == (a: FlipFlopSDK.Device.CameraType, b: FlipFlopSDK.Device.CameraType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var cameras: [FlipFlopSDK.Device.CameraType] {
    get
  }
  public static var allDevicesWithCamera: [FlipFlopSDK.Device] {
    get
  }
  @available(*, deprecated, renamed: "allDevicesWithWideCamera")
  public static var allDevicesWithNormalCamera: [FlipFlopSDK.Device] {
    get
  }
  public static var allDevicesWithWideCamera: [FlipFlopSDK.Device] {
    get
  }
  public static var allDevicesWithTelephotoCamera: [FlipFlopSDK.Device] {
    get
  }
  public static var allDevicesWithUltraWideCamera: [FlipFlopSDK.Device] {
    get
  }
  public var hasCamera: Swift.Bool {
    get
  }
  @available(*, deprecated, renamed: "hasWideCamera")
  public var hasNormalCamera: Swift.Bool {
    get
  }
  public var hasWideCamera: Swift.Bool {
    get
  }
  public var hasTelephotoCamera: Swift.Bool {
    get
  }
  public var hasUltraWideCamera: Swift.Bool {
    get
  }
}
open class SwiftyGifManager {
  public static var defaultManager: FlipFlopSDK.SwiftyGifManager
  open var haveCache: Swift.Bool
  open var remoteCache: [Foundation.URL : Foundation.Data]
  public init(memoryLimit: Swift.Int)
  @objc deinit
  public func startTimerIfNeeded()
  public func stopTimer()
  open func addImage(_ image: UIKit.UIImage)
  open func deleteImage(_ image: UIKit.UIImage)
  open func clear()
}
public protocol HLSPlayerDelegate : AnyObject {
  func onPrepared(player: FlipFlopSDK.HLSPlayer)
  func onPaused(player: FlipFlopSDK.HLSPlayer)
  func onStarted(player: FlipFlopSDK.HLSPlayer)
  func onStopped(player: FlipFlopSDK.HLSPlayer)
  func onCompleted(player: FlipFlopSDK.HLSPlayer)
  func onProgressUpdated(player: FlipFlopSDK.HLSPlayer, seconds: Swift.Float64)
  func onError(player: FlipFlopSDK.HLSPlayer, error: Swift.Error)
  func onVideoResolutionSize(player: FlipFlopSDK.HLSPlayer, size: CoreGraphics.CGSize)
}
@objc open class HLSPlayer : ObjectiveC.NSObject {
  open var isRepeat: Swift.Bool
  open var isPictureInPictureSupported: Swift.Bool {
    get
  }
  open var isPictureInPictureActive: Swift.Bool {
    get
  }
  open var videoGravity: AVFoundation.AVLayerVideoGravity {
    get
    set
  }
  open var isMuted: Swift.Bool {
    get
    set
  }
  open var duration: Swift.Float64 {
    get
  }
  open var forwardPlaybackEndtime: CoreMedia.CMTime? {
    get
    set
  }
  public init(url: Foundation.URL, view: UIKit.UIView, delegate: FlipFlopSDK.HLSPlayerDelegate?)
  @objc deinit
  open func start()
  open func pause()
  open func resume()
  open func seekTo(seconds: Swift.Float64, exactly: Swift.Bool = false, completion: ((Swift.Float64) -> Swift.Void)?)
  open func stop()
  open func startPIP()
  open func stopPIP()
  @objc override dynamic public init()
}
extension HLSPlayer {
  @objc override dynamic open func observeValue(forKeyPath keyPath: Swift.String?, of object: Any?, change: [Foundation.NSKeyValueChangeKey : Any]?, context: Swift.UnsafeMutableRawPointer?)
}
extension HLSPlayer : AVKit.AVPictureInPictureControllerDelegate {
}
open class Responder {
  public typealias Handler = ([Any?]) -> Swift.Void
  public init(result: @escaping FlipFlopSDK.Responder.Handler, status: FlipFlopSDK.Responder.Handler? = nil)
  @objc deinit
}
open class RTMPConnection : FlipFlopSDK.EventDispatcher {
  public static let defaultWindowSizeS: Swift.Int64
  public static let supportedProtocols: Swift.Set<Swift.String>
  public static let defaultPort: Swift.Int
  public static let defaultSecurePort: Swift.Int
  public static let defaultFlashVer: Swift.String
  public static let defaultChunkSizeS: Swift.Int
  public static let defaultCapabilities: Swift.Int
  public static let defaultObjectEncoding: FlipFlopSDK.RTMPObjectEncoding
  public enum Code : Swift.String {
    case callBadVersion
    case callFailed
    case callProhibited
    case connectAppshutdown
    case connectClosed
    case connectFailed
    case connectIdleTimeOut
    case connectInvalidApp
    case connectNetworkChange
    case connectRejected
    case connectSuccess
    public var level: Swift.String {
      get
    }
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  open var swfUrl: Swift.String?
  open var pageUrl: Swift.String?
  open var timeout: Swift.Int {
    get
    set
  }
  open var qualityOfService: Dispatch.DispatchQoS {
    get
    set
  }
  open var flashVer: Swift.String
  open var chunkSize: Swift.Int
  open var uri: Foundation.URL? {
    get
  }
  open var connected: Swift.Bool {
    get
  }
  open var requireNetworkFramework: Swift.Bool
  open var parameters: Any?
  open var objectEncoding: FlipFlopSDK.RTMPObjectEncoding
  open var totalBytesIn: Swift.Int64 {
    get
  }
  open var totalBytesOut: Swift.Int64 {
    get
  }
  open var totalStreamsCount: Swift.Int {
    get
  }
  @objc dynamic open var previousQueueBytesOut: [Swift.Int64] {
    get
  }
  @objc dynamic open var currentBytesInPerSecond: Swift.Int32 {
    get
  }
  @objc dynamic open var currentBytesOutPerSecond: Swift.Int32 {
    get
  }
  override public init()
  @objc deinit
  open func call(_ commandName: Swift.String, responder: FlipFlopSDK.Responder?, arguments: Any?...)
  open func connect(_ command: Swift.String, arguments: Any?...)
  open func close()
  override public init(target: Swift.AnyObject)
}
public enum RTMPObjectEncoding : Swift.UInt8 {
  case amf0
  case amf3
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public enum FoundationTransportError : Swift.Error {
  case invalidRequest
  case invalidOutputStream
  case timeout
  public static func == (a: FlipFlopSDK.FoundationTransportError, b: FlipFlopSDK.FoundationTransportError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@objc public class FoundationTransport : ObjectiveC.NSObject, FlipFlopSDK.Transport, Foundation.StreamDelegate {
  public var usingTLS: Swift.Bool {
    get
  }
  public init(streamConfiguration: ((Foundation.InputStream, Foundation.OutputStream) -> Swift.Void)? = nil)
  @objc deinit
  public func connect(url: Foundation.URL, timeout: Swift.Double = 10, certificatePinning: FlipFlopSDK.CertificatePinning? = nil)
  public func disconnect()
  public func register(delegate: FlipFlopSDK.TransportEventClient)
  public func write(data: Foundation.Data, completion: @escaping ((Swift.Error?) -> ()))
  @objc open func stream(_ aStream: Foundation.Stream, handle eventCode: Foundation.Stream.Event)
  @objc override dynamic public init()
}
public class Queuer {
  public static let shared: FlipFlopSDK.Queuer
  final public let queue: Foundation.OperationQueue
  public var operationCount: Swift.Int {
    get
  }
  public var operations: [Foundation.Operation] {
    get
  }
  public var qualityOfService: Foundation.QualityOfService {
    get
    set
  }
  public var isExecuting: Swift.Bool {
    get
  }
  public var maxConcurrentOperationCount: Swift.Int {
    get
    set
  }
  public init(name: Swift.String, maxConcurrentOperationCount: Swift.Int = Int.max, qualityOfService: Foundation.QualityOfService = .default)
  public func cancelAll()
  public func pause()
  public func resume()
  public func waitUntilAllOperationsAreFinished()
  @objc deinit
}
extension Queuer {
  public func addOperation(_ operation: @escaping () -> Swift.Void)
  public func addOperation(_ operation: Foundation.Operation)
  public func addChainedOperations(_ operations: [Foundation.Operation], completionHandler: (() -> Swift.Void)? = nil)
  public func addChainedOperations(_ operations: Foundation.Operation..., completionHandler: (() -> Swift.Void)? = nil)
  public func addCompletionHandler(_ completionHandler: @escaping () -> Swift.Void)
}
extension Queuer {
  public typealias QueueStateList = [FlipFlopSDK.OperationState]
  public func state() -> FlipFlopSDK.Queuer.QueueStateList
  public static func state(of queue: Foundation.OperationQueue) -> FlipFlopSDK.Queuer.QueueStateList
}
@_inheritsConvenienceInitializers @objc public class FFStreamerConfig : ObjectiveC.NSObject {
  @objc public var preset: FlipFlopSDK.Preset
  @objc public var videoProfile: Swift.String
  @objc public var videoBitrate: Swift.Int
  @objc public var videoBitrateChangeRatio: Swift.Double
  @objc public var keyFrameInterval: Swift.Int
  @objc public var fps: Swift.Int
  @objc public var sampleRate: Swift.Int
  @objc public var audioBitrate: Swift.Int
  @objc public var cameraPos: AVFoundation.AVCaptureDevice.Position
  @objc public var visibility: Swift.String
  @objc public var videoGravity: AVFoundation.AVLayerVideoGravity
  @objc override dynamic public init()
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
  @objc deinit
}
@objc public protocol FFStreamerDelegate {
  @objc func onPrepared()
  @objc func onStarted()
  @objc func onStopped()
  @objc func onStreamStatus(notification: Foundation.Notification)
  @objc func onError(error: FlipFlopSDK.FFError)
  @objc func onChatMessgeReceived(message: FlipFlopSDK.FFMessage)
  @objc func onChatStatReceived(stat: FlipFlopSDK.FFStat)
  @objc func onInSufficentBW()
  @objc func onSufficentBW()
  @objc func onVideoBitrateChanged(newBitrate: Swift.Int)
}
@objc public enum StreamingProtocol : Swift.Int {
  case rtmp
  case webrtc
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers @objc public class FFStreamer : ObjectiveC.NSObject {
  @objc weak public var delegate: FlipFlopSDK.FFStreamerDelegate?
  @objc public var autoRetryTime: Swift.Double
  @objc public var chatHeartbitTime: Swift.Double
  @objc public var continuousAutofocus: Swift.Bool {
    @objc get
    @objc set
  }
  @objc public var continuousExposure: Swift.Bool {
    @objc get
    @objc set
  }
  @objc public var exposureTargetBias: Swift.Float {
    @objc get
    @objc set
  }
  @objc public var minExposureTargetBias: Swift.Float {
    @objc get
  }
  @objc public var maxExposureTargetBias: Swift.Float {
    @objc get
  }
  @objc public var currentBitrate: Swift.Int {
    @objc get
  }
  @objc public var videoBitrateOnFly: Swift.Int {
    @objc get
    @objc set
  }
  @objc public var adaptiveBitrate: Swift.Bool {
    @objc get
    @objc set
  }
  @objc deinit
  @objc public func prepare(preview: UIKit.UIView, config: FlipFlopSDK.FFStreamerConfig = FFStreamerConfig())
  public func start(sdk: FlipFlopSDK.FlipFlop, streamkey: Swift.String, livekey: Swift.String)
  @objc public func cameraCapture() -> UIKit.UIImage?
  @objc public func stop()
  @objc public func reset()
  @objc public func sendMessage(text: Swift.String, data: Swift.String? = nil, customType: Swift.String? = nil)
  @objc public func sendWhispher(receiver: Swift.String, text: Swift.String, data: Swift.String? = nil, customType: Swift.String? = nil)
  @objc public func sendCommand(text: Swift.String, data: Swift.String? = nil, customType: Swift.String? = nil)
  @objc public func switchCamera()
  @objc public func videoMirror(mirror: Swift.Bool)
  @objc public func zoom(factor: CoreGraphics.CGFloat)
  @objc public func setBackground(backgroundImage: UIKit.UIImage?, scale: CoreGraphics.CGFloat = 0.25)
  public func setFilter(filter: FlipFlopSDK.VideoFilter)
  public func playGif(named: Swift.String, completion: (() -> Swift.Void)?) throws
  @objc public func mute(on: Swift.Bool)
  @objc public func setPointOfInterest(focus: CoreGraphics.CGPoint)
  @objc public func setPointOfInterest(exposure: CoreGraphics.CGPoint)
  @objc override dynamic public init()
}
extension FFStreamer {
  public func onInSufficentBW()
  public func onSufficentBW()
  public func onRTMPConnected()
  public func onRTMPDisconnected()
  public func onRTMPStarted()
  public func onRTMPStatus(notification: Foundation.Notification)
  public func onRTMPStopped()
  public func onRTMPError(notification: Foundation.Notification)
  public func onVideoBitrateChanged(newBitrate: Swift.Int, maxBitrate: Swift.Int)
}
extension FFStreamer : FlipFlopSDK.WebRTCStreamerDelegate {
  public func onWebRTCConnected()
  public func onWebRTCDisconnected()
  public func onWebRTCStarted()
  public func onWebRTCStopped()
  public func onWebRTCError(notification: Foundation.Notification)
}
extension FFStreamer {
  public func onConnected()
}
@_hasMissingDesignatedInitializers open class RTMPSharedObject : FlipFlopSDK.EventDispatcher {
  public static func getRemote(withName: Swift.String, remotePath: Swift.String, persistence: Swift.Bool) -> FlipFlopSDK.RTMPSharedObject
  open var objectEncoding: FlipFlopSDK.RTMPObjectEncoding {
    get
  }
  open var data: [Swift.String : Any?] {
    get
  }
  open func setProperty(_ name: Swift.String, _ value: Any?)
  open func connect(_ rtmpConnection: FlipFlopSDK.RTMPConnection)
  open func clear()
  open func close()
  override public init()
  override public init(target: Swift.AnyObject)
  @objc deinit
}
extension RTMPSharedObject : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@objc @_hasMissingDesignatedInitializers final public class NetClient : FlipFlopSDK.NetSocket {
  override final public func listen()
  @objc override dynamic public init()
  @objc deinit
}
public enum HTTPUpgradeError : Swift.Error {
  case notAnUpgrade(Swift.Int)
  case invalidData
}
public struct HTTPWSHeader {
  public static func createUpgrade(request: Foundation.URLRequest, supportsCompression: Swift.Bool, secKeyValue: Swift.String) -> Foundation.URLRequest
  public static func generateWebSocketKey() -> Swift.String
}
public enum HTTPEvent {
  case success([Swift.String : Swift.String])
  case failure(Swift.Error)
}
public protocol HTTPHandlerDelegate : AnyObject {
  func didReceiveHTTP(event: FlipFlopSDK.HTTPEvent)
}
public protocol HTTPHandler {
  func register(delegate: FlipFlopSDK.HTTPHandlerDelegate)
  func convert(request: Foundation.URLRequest) -> Foundation.Data
  func parse(data: Foundation.Data) -> Swift.Int
}
public protocol HTTPServerDelegate : AnyObject {
  func didReceive(event: FlipFlopSDK.HTTPEvent)
}
public protocol HTTPServerHandler {
  func register(delegate: FlipFlopSDK.HTTPServerDelegate)
  func parse(data: Foundation.Data)
  func createResponse(headers: [Swift.String : Swift.String]) -> Foundation.Data
}
public struct URLParts {
}
extension URL {
  public var isTLSScheme: Swift.Bool {
    get
  }
  public func getParts() -> FlipFlopSDK.URLParts?
}
extension FlipFlopSDK.CloseCode : Swift.Equatable {}
extension FlipFlopSDK.CloseCode : Swift.Hashable {}
extension FlipFlopSDK.CloseCode : Swift.RawRepresentable {}
extension FlipFlopSDK.FrameOpCode : Swift.Equatable {}
extension FlipFlopSDK.FrameOpCode : Swift.Hashable {}
extension FlipFlopSDK.FrameOpCode : Swift.RawRepresentable {}
extension FlipFlopSDK.FLVAVCPacketType : Swift.Equatable {}
extension FlipFlopSDK.FLVAVCPacketType : Swift.Hashable {}
extension FlipFlopSDK.FLVAVCPacketType : Swift.RawRepresentable {}
extension FlipFlopSDK.FLVFrameType : Swift.Equatable {}
extension FlipFlopSDK.FLVFrameType : Swift.Hashable {}
extension FlipFlopSDK.FLVFrameType : Swift.RawRepresentable {}
extension FlipFlopSDK.FLVTagType : Swift.Equatable {}
extension FlipFlopSDK.FLVTagType : Swift.Hashable {}
extension FlipFlopSDK.FLVTagType : Swift.RawRepresentable {}
extension FlipFlopSDK.Logboard.Level : Swift.Equatable {}
extension FlipFlopSDK.Logboard.Level : Swift.Hashable {}
extension FlipFlopSDK.Logboard.Level : Swift.RawRepresentable {}
extension FlipFlopSDK.Reachability.Connection : Swift.Equatable {}
extension FlipFlopSDK.Reachability.Connection : Swift.Hashable {}
extension FlipFlopSDK.FFMessageType : Swift.Equatable {}
extension FlipFlopSDK.FFMessageType : Swift.Hashable {}
extension FlipFlopSDK.FFMessageType : Swift.RawRepresentable {}
extension FlipFlopSDK.H264Encoder.Option : Swift.RawRepresentable {}
extension FlipFlopSDK.DefaultAVRecorderDelegate.FileType : Swift.Equatable {}
extension FlipFlopSDK.DefaultAVRecorderDelegate.FileType : Swift.Hashable {}
extension FlipFlopSDK.SecurityErrorCode : Swift.Equatable {}
extension FlipFlopSDK.SecurityErrorCode : Swift.Hashable {}
extension FlipFlopSDK.SecurityErrorCode : Swift.RawRepresentable {}
extension FlipFlopSDK.FLVVideoCodec : Swift.Equatable {}
extension FlipFlopSDK.FLVVideoCodec : Swift.Hashable {}
extension FlipFlopSDK.FLVVideoCodec : Swift.RawRepresentable {}
extension FlipFlopSDK.HKPictureInPicureControllerPosition : Swift.Equatable {}
extension FlipFlopSDK.HKPictureInPicureControllerPosition : Swift.Hashable {}
extension FlipFlopSDK.ScalingMode : Swift.Equatable {}
extension FlipFlopSDK.ScalingMode : Swift.Hashable {}
extension FlipFlopSDK.ScalingMode : Swift.RawRepresentable {}
extension FlipFlopSDK.AVMixer.Option : Swift.RawRepresentable {}
extension FlipFlopSDK.ByteArray.Error : Swift.Equatable {}
extension FlipFlopSDK.ByteArray.Error : Swift.Hashable {}
extension FlipFlopSDK.FLVAudioCodec : Swift.Equatable {}
extension FlipFlopSDK.FLVAudioCodec : Swift.Hashable {}
extension FlipFlopSDK.FLVAudioCodec : Swift.RawRepresentable {}
extension FlipFlopSDK.FLVSoundSize : Swift.Equatable {}
extension FlipFlopSDK.FLVSoundSize : Swift.Hashable {}
extension FlipFlopSDK.FLVSoundSize : Swift.RawRepresentable {}
extension FlipFlopSDK.FLVSoundType : Swift.Equatable {}
extension FlipFlopSDK.FLVSoundType : Swift.Hashable {}
extension FlipFlopSDK.FLVSoundType : Swift.RawRepresentable {}
extension FlipFlopSDK.TCPTransportError : Swift.Equatable {}
extension FlipFlopSDK.TCPTransportError : Swift.Hashable {}
extension FlipFlopSDK.AudioCodec.Destination : Swift.Equatable {}
extension FlipFlopSDK.AudioCodec.Destination : Swift.Hashable {}
extension FlipFlopSDK.Preset : Swift.Equatable {}
extension FlipFlopSDK.Preset : Swift.Hashable {}
extension FlipFlopSDK.Preset : Swift.RawRepresentable {}
extension FlipFlopSDK.FLVSoundRate : Swift.Equatable {}
extension FlipFlopSDK.FLVSoundRate : Swift.Hashable {}
extension FlipFlopSDK.FLVSoundRate : Swift.RawRepresentable {}
extension FlipFlopSDK.FoundationSecurityError : Swift.Equatable {}
extension FlipFlopSDK.FoundationSecurityError : Swift.Hashable {}
extension FlipFlopSDK.RTMPStream.Code : Swift.Equatable {}
extension FlipFlopSDK.RTMPStream.Code : Swift.Hashable {}
extension FlipFlopSDK.RTMPStream.Code : Swift.RawRepresentable {}
extension FlipFlopSDK.RTMPStream.PlayTransition : Swift.Equatable {}
extension FlipFlopSDK.RTMPStream.PlayTransition : Swift.Hashable {}
extension FlipFlopSDK.RTMPStream.PlayTransition : Swift.RawRepresentable {}
extension FlipFlopSDK.RTMPStream.HowToPublish : Swift.Equatable {}
extension FlipFlopSDK.RTMPStream.HowToPublish : Swift.Hashable {}
extension FlipFlopSDK.RTMPStream.HowToPublish : Swift.RawRepresentable {}
extension FlipFlopSDK.ErrorType : Swift.Equatable {}
extension FlipFlopSDK.ErrorType : Swift.Hashable {}
extension FlipFlopSDK.EventPhase : Swift.Equatable {}
extension FlipFlopSDK.EventPhase : Swift.Hashable {}
extension FlipFlopSDK.EventPhase : Swift.RawRepresentable {}
extension FlipFlopSDK.AudioCodec.Option : Swift.RawRepresentable {}
extension FlipFlopSDK.StompAckMode : Swift.Equatable {}
extension FlipFlopSDK.StompAckMode : Swift.Hashable {}
extension FlipFlopSDK.FLVAACPacketType : Swift.Equatable {}
extension FlipFlopSDK.FLVAACPacketType : Swift.Hashable {}
extension FlipFlopSDK.FLVAACPacketType : Swift.RawRepresentable {}
extension FlipFlopSDK.Device.Orientation : Swift.Equatable {}
extension FlipFlopSDK.Device.Orientation : Swift.Hashable {}
extension FlipFlopSDK.Device.CameraType : Swift.Equatable {}
extension FlipFlopSDK.Device.CameraType : Swift.Hashable {}
extension FlipFlopSDK.RTMPConnection.Code : Swift.Equatable {}
extension FlipFlopSDK.RTMPConnection.Code : Swift.Hashable {}
extension FlipFlopSDK.RTMPConnection.Code : Swift.RawRepresentable {}
extension FlipFlopSDK.RTMPObjectEncoding : Swift.Equatable {}
extension FlipFlopSDK.RTMPObjectEncoding : Swift.Hashable {}
extension FlipFlopSDK.RTMPObjectEncoding : Swift.RawRepresentable {}
extension FlipFlopSDK.FoundationTransportError : Swift.Equatable {}
extension FlipFlopSDK.FoundationTransportError : Swift.Hashable {}
extension FlipFlopSDK.StreamingProtocol : Swift.Equatable {}
extension FlipFlopSDK.StreamingProtocol : Swift.Hashable {}
extension FlipFlopSDK.StreamingProtocol : Swift.RawRepresentable {}
